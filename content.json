{"meta":{"title":"肥锐's 技术栈","subtitle":"我只是刚好有一些想法以及一台电脑。  ——阿肥锐","description":"我不是程序员，也不是设计师，只是刚好有些想法以及一台电脑","author":"许源锐","url":"http://www.whbxyr.cn"},"pages":[{"title":"","date":"2017-05-13T15:11:35.079Z","updated":"2017-05-13T15:11:35.079Z","comments":true,"path":"baidu_verify_RUVpqOn26C.html","permalink":"http://www.whbxyr.cn/baidu_verify_RUVpqOn26C.html","excerpt":"","text":"RUVpqOn26C"},{"title":"","date":"2017-05-13T15:06:29.038Z","updated":"2017-05-13T15:06:29.038Z","comments":true,"path":"google8f959bed6376f4d8.html","permalink":"http://www.whbxyr.cn/google8f959bed6376f4d8.html","excerpt":"","text":"google-site-verification: google8f959bed6376f4d8.html"},{"title":"","date":"2018-06-01T15:16:53.607Z","updated":"2018-06-01T15:16:53.607Z","comments":true,"path":"contact/index.html","permalink":"http://www.whbxyr.cn/contact/index.html","excerpt":"","text":"我的邮箱： 网易邮箱：`raywhbxyr@163.com`"}],"posts":[{"title":"vue 脚手架之 vue-cli 的使用","slug":"vue-cli","date":"2018-10-20T14:58:29.000Z","updated":"2018-10-21T03:39:20.456Z","comments":true,"path":"2018/10/20/vue-cli/","link":"","permalink":"http://www.whbxyr.cn/2018/10/20/vue-cli/","excerpt":"","text":"&emsp;&emsp;vue 的发展是很快的，围绕 vue 已经有了一个完整的应用生态，比如 vue + vuex + vue-router + axios + webpack 就是一个完整的应用系统了。那么，每次我们要新建一个运用了此应用系统的项目的时候，都要重新搭建项目吗？回答是肯定的，也确实很麻烦，但是 vue-cli 作为一个 vue 的专门脚手架，可以轻松帮我们解决这样的问题。 &emsp;&emsp;vue-cli 目前版本已经到 3.0 了。3.0 版本跟之前的 2.0 、1.0 这两个版本的使用方式已经不太一样了。为了跟上脚手架的发展，本篇文章着重介绍 3.0 版本的使用。 安装及使用12345678910// 假如你之前安装过 3.0 以前的版本，需要先执行以下命令，否则忽略npm uninstall vue-cli -g// 全局安装最新的 vue-clinpm install -g @vue/cli// 创建项目vue create hello-world// 开启服务npm run serve// 项目打包npm run build &emsp;&emsp;以上介绍的都只是最基本的使用，由于文章篇幅限制，就不在这里展开详细的使用介绍，详见文档 Vue CLI 3 在 3.0 版本下使用 2.0 版本的命令&emsp;&emsp;Vue CLI 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具：1234npm install -g @vue/cli-init// vue init 的运行效果将会跟 vue-cli@2.x 相同vue init webpack my-projectvue-cli@2.x webpack my-project &emsp;&emsp;vue init 创建出来的项目模板是基于 webpack 3 及以下版本的，如果你想使用最新的 webpack 4 版本，可以使用以下命令创建项目：1vue init noamkfir/webpack#webpack-4 project 注意：winpty 命令的使用&emsp;&emsp;如果你在 Windows 上通过 minTTY 使用 Git Bash，交互提示符并不工作。你必须通过 winpty vue.cmd create hello-world 启动这个命令。另外，有些命令在 git bash 里面执行后会乱码，在命令前面加上 winpty 也可以解决乱码问题。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"},{"name":"脚手架","slug":"脚手架","permalink":"http://www.whbxyr.cn/tags/脚手架/"}]},{"title":"window.location 对象详解","slug":"location","date":"2017-08-27T04:17:16.000Z","updated":"2017-09-09T08:12:27.610Z","comments":true,"path":"2017/08/27/location/","link":"","permalink":"http://www.whbxyr.cn/2017/08/27/location/","excerpt":"","text":"window.location 的属性&emsp;&emsp;本文通过一个示例 url，讲述window.location的各个属性。假设该url如下：1https://www.baidu.com/s?wd=location.hash&amp;rsv_spt=1&amp;rsv_iqid=0xa78ca3100003b820&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_t=6decUG6FR%2BbaSb%2FPMsTCZmiKd2aU05OANFzmoTyRD5hNNitxtu1jTmnpxMiD1NK6nql%2F&amp;oq=location.hash&amp;inputT=6&amp;rsv_sug3=9&amp;rsv_sug1=8&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_pq=a80d243900049765&amp;rsv_sug4=190534#imhere &emsp;&emsp;当我们访问这个网页的时候，在控制台运行以下代码：12345678910111213141516// 控制台中输入以下代码：JSON.stringify(window.location);/* 可以获得以下字符串（为方便查看，手动缩进规范处理了下）\"&#123; \"href\":\"https://www.baidu.com/s?wd=location.hash&amp;rsv_spt=1&amp;rsv_iqid=0xa78ca3100003b820&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_t=6decUG6FR%2BbaSb%2FPMsTCZmiKd2aU05OANFzmoTyRD5hNNitxtu1jTmnpxMiD1NK6nql%2F&amp;oq=location.hash&amp;inputT=6&amp;rsv_sug3=9&amp;rsv_sug1=8&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_pq=a80d243900049765&amp;rsv_sug4=190534#imhere\", \"ancestorOrigins\":&#123;&#125;, \"origin\":\"https://www.baidu.com\", \"protocol\":\"https:\", \"host\":\"www.baidu.com\", \"hostname\":\"www.baidu.com\", \"port\":\"\", \"pathname\":\"/s\", \"search\":\"?wd=location.hash&amp;rsv_spt=1&amp;rsv_iqid=0xa78ca3100003b820&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_t=6decUG6FR%2BbaSb%2FPMsTCZmiKd2aU05OANFzmoTyRD5hNNitxtu1jTmnpxMiD1NK6nql%2F&amp;oq=location.hash&amp;inputT=6&amp;rsv_sug3=9&amp;rsv_sug1=8&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_pq=a80d243900049765&amp;rsv_sug4=190534\", \"hash\":\"#imhere\"&#125;\"*/ &emsp;&emsp;由上可得 window.location 的10个属性：&emsp;&emsp;href / ancestorOrigins / origin / protocol / host&emsp;&emsp;hostname / port / pathname / search / hash window.location.href整个URl字符串(在浏览器中就是完整的地址栏)本例返回值: https://www.baidu.com/s?wd=location.hash&amp;rsv_spt=1&amp;rsv_iqid=0xa78ca3100003b820&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_t=6decUG6FR%2BbaSb%2FPMsTCZmiKd2aU05OANFzmoTyRD5hNNitxtu1jTmnpxMiD1NK6nql%2F&amp;oq=location.hash&amp;inputT=6&amp;rsv_sug3=9&amp;rsv_sug1=8&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_pq=a80d243900049765&amp;rsv_sug4=190534 window.location.protocolURL 的协议部分本例返回值: https: window.location.hostURL 的主机部分本例返回值: www.baidu.com window.location.hostnameURL 的主机部分，在这里 window.location.hostname === window.location.host本例返回值: www.baidu.com window.location.portURL 的端口部分如果采用默认的80端口(即使添加了:80)，那么返回值并不是默认的80而是空字符本例返回值: “” window.location.pathnameURL 的路径部分(就是文件地址)本例返回值: /s window.location.search查询(参数)部分除了给动态语言赋值以外，我们同样可以给静态页面,并使用javascript来获得相信应的参数值本例返回值: ?wd=location.hash&amp;rsv_spt=1&amp;rsv_iqid=0xa78ca3100003b820&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_t=6decUG6FR%2BbaSb%2FPMsTCZmiKd2aU05OANFzmoTyRD5hNNitxtu1jTmnpxMiD1NK6nql%2F&amp;oq=location.hash&amp;inputT=6&amp;rsv_sug3=9&amp;rsv_sug1=8&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_pq=a80d243900049765&amp;rsv_sug4=190534 window.location.hash锚点本例返回值: #imhere window.location 改变当前页面 url 的方法 window.location = ‘xxx’; location = ‘xxx’; window.location.href = ‘xxx’; location.href = ‘xxx’; window.replace(‘xxx’); &emsp;&emsp;这五种方法都会让浏览器的历史记录里面多一项，但是有一个较大的区别就是前四种方法依然可以通过使用浏览器的“前进”和“后退”按钮回到替换url之前的原始url，但是对于最后一种方法 window.replace(url)，则将失去浏览器的“前进”和“后退”按钮功能，因为该方法通过指定URL替换当前缓存在历史里（客户端）的项目，因此当使用replace方法之后，你不能通过“前进”和“后退”来访问已经被替换的URL。 window.location.reload([bForceGet])&emsp;&emsp;window.location.reload([bForceGet])方法接收一个参数，默认为false，即刷新当前页面并如果有缓存的话就从缓存里面读取页面。当传入这个方法的参数为true时，则表示强刷页面，效果与用户直接 Ctrl + F5 的效果是一样的，即直接从服务器获取最新的页面。 使用 window.location.hash 欺骗浏览器&emsp;&emsp;有这么一个场景，就是在一个页面里面，浏览到了你想收藏的地方，这时候你收藏了链接，下次再打开的时候，却发现还是要从头开始找那个你想收藏的地方。但是，使用 window.location.hash 可以解决这个问题。&emsp;&emsp;解决方法就是给链接加上一个hash值，每次打开链接的时候使用js去获取这个hash值，并根据不同的hash值显示不同的页面。这样，还可以欺骗浏览器，让浏览器以为加了hash的链接是一个新的页面，这样就可以充分使用浏览器的“前进”和“后退”功能了。123456789101112131415161718// 示意代码window.onload = function () &#123; var hash = window.location.hash; switch (hash) &#123; case &apos;part1&apos;: showPart1(); break; case &apos;part2&apos;: showPart2(); break; case &apos;&apos;: showPart0(); break; default: showPart0(); break; &#125;&#125;; 注意window.location === document.location 在没有使用 iframe 时，结果为 true，即两者没有什么区别，但是一旦页面中使用了 iframe 框架，就会有不同了，在 iframe 中的 window.location 等同于 top.location，但是不一定与 document.location 等同。 总结&emsp;&emsp;合理利用window.location可以实现很多有趣的功能，比如在 a 标签中使用 href=”#” 可以实现快速回到页面顶部。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"}]},{"title":"理解语义化","slug":"semantic","date":"2017-07-22T11:17:16.000Z","updated":"2018-06-01T15:16:53.591Z","comments":true,"path":"2017/07/22/semantic/","link":"","permalink":"http://www.whbxyr.cn/2017/07/22/semantic/","excerpt":"","text":"&emsp;&emsp;以前开始学前端、作为一名萌新的时候，一上来就是狂刷 html 的各种标签，拿到 &lt;div&gt; &lt;span&gt; 就是学习如何实现各种炫酷效果，很多实现都基本会首选这两个标签，但是却基本不考虑语义化这种看似“很玄”的东西，但是随着自己接触的项目逐渐增多以及现 HTML 5 的流行，慢慢发现如果有更高追求的话，语义化就是一个不得不考虑的点。 语义化的定义&emsp;&emsp;上维基百科搜了一下，它对语义化的定义如下： 语义化是前端开发里面的一个专用术语，其优点在于标签语义化有助于构架良好的html结构，有利于搜索引擎的建立索引、抓取；另外，亦有利于页面在不同的设备上显示尽可能相同；此外，亦有利于构建清晰的机构，有利于团队的开发、维护。 &emsp;&emsp;这段维基百科是2012年编写的，可见语义化并不是一个新概念，在搜索引擎大行其道的web2.0时代，甚至是在更早的时候，大家就都已经意识到了语义化这个概念了，语义化并不是 HTML 5 专有的概念。&emsp;&emsp;在我看来，语义化的 html 就是让相应的标签做相应的事情，在没有 CSS 样式的情况下，网页也以正确的文档格式显示。这样不仅便于开发者阅读理解代码以及写出更优雅的代码，还能页面内容结构化，让网络爬虫很好地解析网页，实现 SEO 优化。 总结语义化的作用 在没有 CSS 样式的时候能够清楚体现页面的结构，增强可读性 语义化的 html 让开发者更容易看明白，便于团队的开发和维护，提高团队的开发效率 有利于网页在多个终端的浏览器内正常渲染、显示 有利于网页的 SEO 优化，结构语义化的 html 能够被搜素引擎更好地理解和爬取 怎么写语义化的 html&emsp;&emsp;实现语义化的 html，关键就是要实现结构与样式分离。站在 html 的角度上，它只告诉我们它包含的内容是什么，意义是什么，但是它的样式不应该由自己来决定，而应该由 CSS 来决定。&emsp;&emsp;总的来说，写语义化 的 html 其实并不苦难。主要包含以下几点： 掌握 html 中各个标签的语义，比如&lt;h1&gt;~&lt;h6&gt;表示标题，&lt;p&gt;表示段落，&lt;header&gt;、&lt;main&gt;、&lt;footer&gt;分别表示页面的头部、主体以及页脚等等。 在构建 html 的时候，提前想好某块内容的结构语义，判断它是一个标题还是段落或者一篇文章等等。 在实际敲 html 代码的时候，根据具体语义选择对应的标签就可以了。 有哪些语义化的标签&emsp;&emsp;举一些 HTML 5 的新的语义化标签： &lt;header&gt; &lt;footer&gt; &lt;hgroup&gt; &lt;nav&gt; &lt;aside&gt; &lt;section&gt; &lt;article&gt; …… &emsp;&emsp;下面图片展示的是一个语义化 html 的例子。 参考资料HTML 5的革新——语义化标签(一)什么是语义化的HTML?有何意义？为什么要做到语义化？","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"html","slug":"html","permalink":"http://www.whbxyr.cn/tags/html/"}]},{"title":"动态加载js脚本并判断是否加载完成","slug":"judgeAsyncJs","date":"2017-07-17T11:17:16.000Z","updated":"2018-06-01T15:16:53.575Z","comments":true,"path":"2017/07/17/judgeAsyncJs/","link":"","permalink":"http://www.whbxyr.cn/2017/07/17/judgeAsyncJs/","excerpt":"","text":"&emsp;&emsp;异步加载js的方法可以是先创建一个&lt;script&gt;标签，再给这个标签添加src属性并将该元素添加到文档后，这时候浏览器就会开始异步加载JavaScript文件。它与图像不同的是，为图像创建的&lt;img&gt;标签，一旦给予了它src属性，它就会立马加载图片，而不管&lt;img&gt;标签是否已经被插入文档中。 &emsp;&emsp;因此，对于&lt;script&gt;元素而言，指定src属性和指定事件处理程序的先后顺序就不重要了，在这一点上，与&lt;link&gt;标签的表现是一致的，&lt;link&gt;标签在href属性被赋值后也不会立即下载样式表，只有将该元素添加到文档中后才会开始下载，因此指定href属性和指定事件处理程序的先后顺序也不重要了；而对于&lt;img&gt;元素而言，则必须先指定事件处理程序，再赋予src属性，否则会出现捕获不到加载完成事件的情况。 动态加载js文件并判断状态（一）监听 load 事件&emsp;&emsp;其中使用了跨浏览器的 EventUtil 对象，详见我的文章 兼容浏览器的事件处理程序 EventUtil！12345678910111213// 待文档及资源加载完毕后，再异步动态加载一个js文件EventUtil.addHandler(window, 'load', function () &#123; // 创建一个&lt;script&gt;标签 var script = document.createElement('script'); // 添加 load 事件的监听 EventUtil.addHandler(script, 'load', function () &#123; console.log('异步脚本加载完毕'); &#125;); // 赋予 src 属性 script.src = 'example.js'; // 将&lt;script&gt;标签插入到文档中后开始加载js文件 document.body.appendChild(script);&#125;); &emsp;&emsp;以上便是异步加载js文件并判断是否加载完成的方法之一。 （二）监听对象的 readyState 属性&emsp;&emsp;其中依然使用了跨浏览器的 EventUtil 对象。1234567891011121314151617181920212223// 待文档及资源加载完毕后，再异步动态加载一个js文件EventUtil.addHandler(window, 'load', function () &#123; // 创建一个&lt;script&gt;标签 var script = document.createElement('script'); // 添加 readystatechange 事件的监听 EventUtil.addHandler(script, 'readystatechange', function (event) &#123; // 获取事件 event = EventUtil.getEvent(event); // 获取发生相应事件的 DOM 对象 var target = EventUtil.getTarget(event); // 根据对象的 readyState 属性的值来判断加载是否完成 if (target.readyState === 'loaded' || target.readyState === 'complete') &#123; EventUtil.removeHandler(target, 'readystatechange', arguments.callee); console.log('异步脚本加载完毕'); &#125; &#125;); // 赋予 src 属性 script.src = 'example.js'; // 将&lt;script&gt;标签插入到文档中后开始加载js文件 document.body.appendChild(script);&#125;); &emsp;&emsp;这种方法主要是依据 readystatechange 事件来判断动态加载的js文件是否加载完成。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"}]},{"title":"调研 flv.js","slug":"flvjs","date":"2017-07-17T07:17:16.000Z","updated":"2018-06-01T15:16:53.560Z","comments":true,"path":"2017/07/17/flvjs/","link":"","permalink":"http://www.whbxyr.cn/2017/07/17/flvjs/","excerpt":"","text":"前言&emsp;&emsp;目前常见的直播协议及其简单介绍如下： RTMP: 底层基于TCP，在浏览器端依赖Flash。 HTTP-FLV: 基于HTTP流式IO传输FLV，依赖浏览器支持播放FLV。 WebSocket-FLV: 基于WebSocket传输FLV，依赖浏览器支持播放FLV。WebSocket建立在HTTP之上，建立WebSocket连接前还要先建立HTTP连接。 HLS: Http Live Streaming，苹果提出基于HTTP的流媒体传输协议。HTML5可以直接打开播放。 RTP: 基于UDP，延迟1秒，浏览器不支持。 &emsp;&emsp;常见直播协议延迟与性能数据（只做对比参考）如下： 传输协议 播放器 延迟 内存 CPU RTMP Flash 1s 430M 11% HTTP-FLV Video 1s 310M 4.4% HLS Video 20s 205M 3% 在支持浏览器的协议里，延迟排序是：&emsp;&emsp;RTMP = HTTP-FLV = WebSocket-FLV &lt; HLS而性能排序则恰好相反：&emsp;&emsp;RTMP &gt; HTTP-FLV = WebSocket-FLV &gt; HLS从这点上看的话， 延迟小的性能反而不好。 另外，通过以上比较，综合延迟以及性能，可见在浏览器上做直播的话，使用 HTTP-FLV 协议是不错的。 什么是flv.js？&emsp;&emsp;flv.js是一个不借助于Flash却可以实现在浏览器上播放HTML5 Flash流媒体视频(FLV)的，由纯原生的JavaScript编写的js插件。&emsp;&emsp;基本原理是通过将 FLV 文件流转码复用成 ISO BMFF（MP4 碎片）片段，然后通过 Media Source Extensions（API） 将 MP4 片段喂进浏览器。它是前bilibili的员工受到hls.js的启发而创作的一个开源项目，github入口请点击这里！ &emsp;&emsp;本文将顺序介绍flv.js的功能、优点、缺点，并在最后给出一个使用flv.js的实例。 flv.js的功能&emsp;&emsp;目前各大浏览器厂商已经默认禁用 Flash，以前常见的Flash直播方案需要用户同意使用Flash后才可以正常使用直播功能，这样的用户体验很致命。&emsp;&emsp;而flv.js则可以在不使用 Flash 的情况下播放FLV流视频。下面列出了它的几点功能： 它是一个具有H.264 + AAC编码器播放功能的FLV 容器 多部分分段视频播放 HTTP FLV 低延迟实时流播放 FLV 通过 WebSocket 实时流播放 兼容 Chrome, FireFox, Safari 10, IE11 和 Edge 开销很低，使用了浏览器的硬件加速 flv.js的优点 HTML5 原生仅支持播放 mp4/webm 格式，flv.js 实现了在HTML5上播放FLV格式视频 建立在采用了硬件加速的Video标签上，因此性能好，支持高清 在 HTML5 上支持了延迟极低的 HTTP FLV 播放，解决了对Flash的依赖问题 支持录播和直播 flv.js的缺点 FLV里所包含的视频编码必须是H.264，音频编码必须是AAC或MP3， IE11和Edge浏览器不支持MP3音频编码，所以FLV里采用的编码最好是H.264+AAC。 在录播上依赖于原生 HTML5 的Video标签和Media Source Extensions API。 在直播上不仅依赖于原生 HTML5 的Video标签和Media Source Extensions API，同时依赖 HTTP-FLV 或者 WebSocket 中的一种协议来传输FLV。其中 HTTP FLV 需通过流式IO去拉取数据，比如fetch或者stream。 flv.min.js 文件gzip压缩后与flash播放器gzip压缩后的大小相差无几。 由于依赖Media Source Extensions API，目前所有iOS和Android4.4.4以下里的浏览器都不支持，也就是说目前对于移动端flv.js基本是不能用的。 使用实例&emsp;&emsp;使用flv.js的一个具体例子可以点击 这里 !&emsp;&emsp;在 Google Chrome 59.0.3071.115 (正式版本) （32 位）中的效果图如下： &emsp;&emsp;而在 Android 6.0.1 的小米4手机的浏览器上是无法使用的。如下图： &emsp;&emsp;另外，其在 iOS 上的 Safari 浏览器下也是无法使用的。 综上，flv.js在移动端上的使用还是比较局限的。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"},{"name":"插件","slug":"插件","permalink":"http://www.whbxyr.cn/tags/插件/"}]},{"title":"使用 js 实现栈并解决正整数\"进制转换\"的问题","slug":"jsStack","date":"2017-07-09T16:18:27.000Z","updated":"2018-06-01T15:16:53.575Z","comments":true,"path":"2017/07/10/jsStack/","link":"","permalink":"http://www.whbxyr.cn/2017/07/10/jsStack/","excerpt":"","text":"&emsp;&emsp;在这篇文章中，我将结合 js 的构造函数以及 js 的数组，实现数据结构栈并利用 js 实现的栈来实现正整数的 进制转换算法，即将正整数转换为其他进制的数（包括二进制到十六进制）。 (一) 利用 js 实现数据结构栈&emsp;&emsp;充分利用 ECMAScript 原生的构造函数以及原生的数据结构数组，可以很容易地实现栈。代码以及注释如下：1234567891011121314151617181920212223242526272829303132function Stack() &#123; // 初始化栈 var items = []; // 入栈 this.push = function (item) &#123; items.push(item); &#125;; // 出栈 this.pop = function () &#123; return items.pop(); &#125;; // 获取栈顶元素 this.peek = function () &#123; return items[items.length - 1]; &#125;; // 判空 this.isEmpty = function () &#123; return items.length === 0; &#125;; // 获取栈的大小 this.size = function () &#123; return items.length; &#125;; // 清空栈 this.clear = function () &#123; items = []; &#125;; // 打印栈 this.print = function () &#123; console.log(items.toString()); &#125;;&#125; (二) 利用栈将正整数转换为其他进制数（2~16）&emsp;&emsp;只要知道十进制数转换为其他进制数的原理，就可以很简单地利用栈来实现。原理就是通过不断地进行除法，将余数放入栈中，等到原来的十进制数变为零时，再将栈中的数据逐个出站拼接，便能获得我们想要的目标进制数。代码以及注释如下所示：12345678910111213141516171819202122232425262728/* * 十进制正整数： decNumber * 目标进制(base &gt;= 2 &amp;&amp; base &lt;= 16)： base */function baseConvert(decNumber, base) &#123; // 初始化余数栈 var remStack = new Stack(); // 初始化余数 var rem; // 初始化转换结果 var baseString = ''; // 解决11到16进制之间的进制数表示问题 var digits = '0123456789ABCDEF'; // 计算余数栈 while (decNumber &gt; 0) &#123; rem = decNumber % base; remStack.push(rem); decNumber = Math.floor(decNumber / base); &#125; // 计算结果 while (!remStack.isEmpty()) &#123; baseString += digits[remStack.pop()]; &#125; return baseString;&#125; &emsp;&emsp;另外，只要知道如何将十进制正整数转换为其他进制的数，那么也可以轻松实现任何进制之间的转换。在我看来，分为两个步骤：&emsp;&emsp;1. 将原始进制数a转换为十进制数b&emsp;&emsp;2. 将得到的b再利用上述算法，即可得到最终的目标进制数c","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"http://www.whbxyr.cn/tags/算法/"}]},{"title":"path.join 与 path.resolve 的区别","slug":"path-join-path-resolve","date":"2017-05-31T13:07:48.000Z","updated":"2018-06-01T15:16:53.575Z","comments":true,"path":"2017/05/31/path-join-path-resolve/","link":"","permalink":"http://www.whbxyr.cn/2017/05/31/path-join-path-resolve/","excerpt":"","text":"何为 path ？&emsp;&emsp;path是node提供的用于处理文件路径的小工具，我们可以通过以下方式引入该模块：1var path = require('path'); &emsp;&emsp;path.join以及path.resolve便是该模块中的两个方法。官方对这两个方法的定义分别如下： path.join([path1][, path2][, …]) path.resolve([from …], to) 用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是”/“，Windows系统是”\\”。 将 to 参数解析为绝对路径。 &emsp;&emsp;很多同学在使用中分不清楚它们两者之间的区别。接下来，我们就来看看它们二者之间的区别。 path.join 与 path.resolve 的区别 相同点 1.二者都是输出路径字符串 2.二者都能正确处理父级标识&#39;../&#39;例子：现假设在 ububtu 的 home 目录的 test 文件夹里新建一个 path.js 文件。（以下均以这个文件作为例子讲解）123456789101112/** * path.js */var path = require('path');// 使用 path.joinconsole.log(path.join(__dirname, '../hexo'));// 输出 /home/whbxyr/hexo// 使用 path.resolveconsole.log(path.resolve(__dirname, '../hexo'));// 输出 /home/whbxyr/hexo &emsp;&emsp;可见二者均是将&#39;../&#39;视为父级目录，而不是当成简单的字符串。 不同点 1.path.join 只是简单的连接路径，而 path.resolve 则是将最后一个参数的路径解析为绝对路径。123456789101112/** * path.js */var path = require('path');// 使用 path.joinconsole.log(path.join('test', './hexo'));// 输出 test/hexo// 使用 path.resolveconsole.log(path.resolve('test', './hexo'));// 输出 /home/whbxyr/test/test/hexo 2.path.join 将&#39;/&#39;视为简单的当前路径，而 path.resolve 将&#39;/&#39;视为根目录。123456789101112/** * path.js */var path = require('path');// 使用 path.joinconsole.log(path.join(__dirname, '/hexo'));// 输出 /home/whbxyr/test/hexo// 使用 path.resolveconsole.log(path.resolve(__dirname, '/hexo'));// 输出 /hexo &emsp;&emsp;path.join 的第二个参数前面有个&#39;/&#39;，但是输出的结果也仅仅是简单的当前路径的连接，而 path.resolve 的第二个参数前面也有&#39;/&#39;，但是由于它将其视为根目录，因此第二个参数的绝对路径便直接是根目录下的。 总结&emsp;&emsp;path.join 与 path.resolve 虽然有时候运行结果是相同的，有些情况下使用哪个都可以，但是它们二者之间还是有本质区别的，我们在平常的使用中应该要多加注意，加以区分。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"},{"name":"node","slug":"node","permalink":"http://www.whbxyr.cn/tags/node/"}]},{"title":"各大浏览器内核(渲染引擎/JS引擎)","slug":"browserCore","date":"2017-04-15T07:17:16.000Z","updated":"2018-06-01T15:16:53.560Z","comments":true,"path":"2017/04/15/browserCore/","link":"","permalink":"http://www.whbxyr.cn/2017/04/15/browserCore/","excerpt":"","text":"简介&emsp;&emsp;在介绍各个主流的浏览器内核之前，首先介绍浏览器内核的组成及其工作原理/作用。 &emsp;&emsp;渲染引擎(又叫排版引擎)以及JS引擎是浏览器内核的两个组成部分。 &emsp;&emsp;渲染引擎负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用PDF阅读器插件（所以想做浏览器插件的同学必须知道浏览器的工作原理），可以显示PDF格式。 &emsp;&emsp;JS引擎负责对JavaScript进行解释、编译和执行，以使网页达到一些动态的效果。 渲染引擎一. Trident/EdgeHTML -&gt; (IE浏览器/Edge浏览器) &emsp;&emsp;Trident是微软的IE浏览器使用的渲染引擎，它是从从早期一款商业性的专利网页浏览器Spyglass Mosaic派生出来的。Window 10发布之后，微软将其内置的浏览器命名为Edge，而Edge浏览器的渲染引擎便是EdgeHTML。 二. WebKit（WebCore） -&gt; (Safari浏览器) &emsp;&emsp;WebKit是苹果公司的Safari浏览器使用的渲染引擎，是KDE（Linux桌面系统）小组的KHTML引擎的一个开源的分支。 三. Chromium/Blink -&gt; (Chrome浏览器) &emsp;&emsp;Chromium是谷歌公司的Chrome浏览器使用的渲染引擎，它是以苹果公司的WebKit作为原型的，是WebKit的一个分支。Chromium引擎把WebKit引擎的代码梳理得更加可读。后来，在2013年的时候，Chrome放弃了Chromium引擎转而使用了基于WebKit2的Blink引擎，其中WebKit2是苹果公司于2010年推出的新的WebKit引擎。 四. Presto -&gt; (Opera浏览器) &emsp;&emsp;Presto是挪威Opera Software ASA公司的Opera浏览器使用的渲染引擎，后来该公司为了减少研发成本，跟随Chrome浏览器先后将渲染引擎改为Chromium 和 Blink。 五. Gecko -&gt; (FireFox浏览器) &emsp;&emsp;Gecko是Mozilla公司的FireFox浏览器使用的渲染引擎，它是一款开源的跨平台渲染引擎，可以在Windows、 BSD、Linux 和 Mac OS X 中使用。 JS引擎一. 微软的JS引擎 JScript Chakra IE3.0-IE8.0 IE9+ 二. 苹果的JS引擎 Nitro 为Safari 4编写 三. Google的JS引擎 V8 开放源代码，由Google丹麦开发，是Chrome浏览器的一部分 四. Opera的JS引擎 Linear A Linear B Futhark Carakan Opera 4.0～6.1 Opera 7.0～9.2 Opera 9.5～10.2 Opera10.50+ 五. Mozilla的JS引擎 SpiderMonkey Rhino TraceMonkey JaegerMonkey JavaScriptCore、WebKit IonMonkey OdinMonkey 第一款JavaScript引擎 完全以Java编写 基于实时编译的引擎 结合追踪和组合码技术大幅提高性能 用于Mozilla Firefox 4.0以上版本 可以对JavaScript编译后的结果进行优化 可以对asm.js进行优化，用于Mozilla Firefox 22.0以上版本","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://www.whbxyr.cn/tags/浏览器/"}]},{"title":"详解应用层协议之 HTTP 协议","slug":"HTTPprotocol","date":"2017-04-14T04:17:11.000Z","updated":"2018-06-01T15:16:53.544Z","comments":true,"path":"2017/04/14/HTTPprotocol/","link":"","permalink":"http://www.whbxyr.cn/2017/04/14/HTTPprotocol/","excerpt":"","text":"&emsp;&emsp;HTTP 协议定义了浏览器（万维网客户端）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。从层次的角度看，HTTP 协议是面向事务的应用层协议，它是万维网上能够可靠地交换文件（包括文本/声音/图像等各种多媒体文件）的重要基础。 (一) http协议的特点 http是面向事务/无状态/无连接的协议 http报文分请求报文和响应报文两种 http的发展路线：0.9 ~ 1.0 ～ 1.1 ～ 2.0 (二) http报文的分类http报文分两类，包括请求报文以及响应报文，两种报文的格式都由三部分组成，包括开始行/首部行/实体主体 三部分。（1）请求报文 即浏览器（万维网客户端）向万维网服务器发送的报文。请求报文中的开始行也称作 请求行，首部行又叫做请求报文的 请求头，实体主体（请求主体）又叫做 http实体（包含首部行和实体主体两部分）的实体主体。各部分的详细格式信息如下图： &emsp;&emsp;例子： &emsp;&emsp;GET /562f25980001b1b106000338.jpg HTTP/1.1&emsp;&emsp;Host img.mukewang.com&emsp;&emsp;User-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36&emsp;&emsp;Accept image/webp,image/,/*;q=0.8&emsp;&emsp;Referer http://www.imooc.com/&emsp;&emsp;Accept-Encoding gzip, deflate, sdch&emsp;&emsp;Accept-Language zh-CN,zh;q=0.8 （2）响应报文 即万维网服务器向浏览器（万维网客户端）发送的报文。响应报文中的开始行也称作状态行，首部行又叫做请求报文的 响应头，实体主体（响应主体）又叫做 http实体（包含首部行和实体主体两部分）的实体主体。各部分的详细格式信息如下图： &emsp;&emsp;例子： &emsp;&emsp;HTTP/1.1 200 OK&emsp;&emsp;Date: Fri, 22 May 2009 06:07:21 GMT&emsp;&emsp;Content-Type: text/html; charset=UTF-8&emsp;&emsp;&emsp;&emsp;&lt;html&gt;&emsp;&emsp;&lt;head&gt;&lt;/head&gt;&emsp;&emsp;&lt;body&gt;&emsp;&emsp;&lt;!--body goes here--&gt;&emsp;&emsp;&lt;/body&gt;&emsp;&emsp;&lt;/html&gt; (三) http报文的状态码（响应报文产生的）http响应报文产生的状态码主要分五类，如下：（1）1xx，表示通知信息的，如请求收到了或正在进行处理。包括 100 - 102 。（2）2xx，表示成功，如接受或知道了。包括 200 - 207 。（3）3xx，表示重定向，如要完成请求还必须采取进一步的行动。包括 300 - 307 。（4）4xx，表示客户的差错，如请求中有错误的语法或不能完成。包括 400 - 418 、421 - 426、449、451。（5）5xx，表示服务器的差错，如服务器失效无法完成请求。包括 500 - 507、509 - 510。其中，还有一个比较少见的状态码 600，它代表万维网服务器只返回了响应主体而没有返回响应头。 (四) http协议中的相关称谓 请求头/响应头（header），即首部行。 http实体，即由首部行（header）以及实体主体（body）两部分组成的，不包括开始行。","categories":[{"name":"技术类-网络协议","slug":"技术类-网络协议","permalink":"http://www.whbxyr.cn/categories/技术类-网络协议/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://www.whbxyr.cn/tags/网络协议/"}]},{"title":"ubuntu下配置 Cisco VPN 的方法","slug":"ubuntuVpn","date":"2017-04-13T06:12:31.000Z","updated":"2018-06-01T15:16:53.591Z","comments":true,"path":"2017/04/13/ubuntuVpn/","link":"","permalink":"http://www.whbxyr.cn/2017/04/13/ubuntuVpn/","excerpt":"","text":"（一） 命令行安装并使用 Cisco VPN1. 连接 Cisco VPN&emsp;&emsp;切换到root后安装vpnc并设置各项参数1234567// 切换到root$ su// 安装vpnc# apt-get install vpnc// 使用vpnc命令并设置参数# vpnc// 之后按照提示输入各项设置，可见下图 2. 查看 Cisco VPN12// 使用命令 ifconfig 查看 Cisco VPN 连接情况# ifconfig 3. 断开 Cisco VPN12// 使用命令 vpnc-disconnect 断开 Cisco VPN# vpnc-disconnect （二）图形界面配置 Cisco VPN（需要先安装）第一步： 命令行安装图形化的 Cisco VPN1$ sudo apt-get install network-manager-vpnc network-manager-vpnc-gnome 第二步： 打开Network Connections 并选择 Cisco Compatible VPN(vpnc)，如下图 第三步： 点击 Create… 后进行配置，配置的参数包括 Gateway(网关)，User name(用户名)，User password(喻户密码)，Group name(组名称)，Group password(组密码)，配置完成后点击 Save 保存设置。如下图： 第三步： 点击 VPN Connections 并选择刚刚设置的 Cisco VPN（比如 VPN connection 1），若能看到以下标志，则说明成功链接 Cisco VPN","categories":[{"name":"技术类-linux","slug":"技术类-linux","permalink":"http://www.whbxyr.cn/categories/技术类-linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://www.whbxyr.cn/tags/ubuntu/"},{"name":"奇淫巧技","slug":"奇淫巧技","permalink":"http://www.whbxyr.cn/tags/奇淫巧技/"}]},{"title":"ubuntu下各种出错情况的解决方法","slug":"ubuntuTip","date":"2017-04-13T05:51:05.000Z","updated":"2018-06-01T15:16:53.591Z","comments":true,"path":"2017/04/13/ubuntuTip/","link":"","permalink":"http://www.whbxyr.cn/2017/04/13/ubuntuTip/","excerpt":"","text":"1. 网络连接报错“device not managed”第一步: 编辑/etc/NetworkManager/NetworkManager.conf：1$ sudo gedit /etc/NetworkManager/NetworkManager.conf 将其中的managed=false改为managed=true 第二步: 重启network-manager service：1$ sudo service network-manager restart 2. Ubuntu下Sublime Text 3解决无法输入中文的方法第一步: 更新并升级系统为最新(较新的系统会解决很多可能出现的问题)1$ sudo apt-get update &amp;&amp; sudo apt-get upgrade 第二步: 克隆项目到本地1$ git clone https://github.com/lyfeyaj/sublime-text-imfix.git 第三步: 运行脚本1$ cd sublime-text-imfix &amp;&amp; ./sublime-imfix 完成! 重新启动后就可以在 Sublime Text 2/3 中 使用 Fcitx了! 注意: 皮肤可能需要自己选择。效果图如下： 3. Ubuntu下解决搜狗输入法无法正常输入中文的方法第一步: 找到搜狗输入法的配置文件12$ cd ~$ cd .config/ 找到的搜狗输入法的配置文件如下图： 第二步: 删除有关搜狗输入法的配置文件123$ rm -rf SogouPY$ rm -rf SogouPY.users$ rm -rf sogou-qimpanel 第三步: 操作系统注销后重新登录，搜狗输入法即可恢复正常 4. Ubuntu下安装 Node 版本管理器nvm的方法12// 执行以下命令，等待安装完成后重启terminal，即可使用nvm安装、使用和管理各种版本的node和npm$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.29.0/install.sh | bash","categories":[{"name":"技术类-linux","slug":"技术类-linux","permalink":"http://www.whbxyr.cn/categories/技术类-linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://www.whbxyr.cn/tags/ubuntu/"},{"name":"奇淫巧技","slug":"奇淫巧技","permalink":"http://www.whbxyr.cn/tags/奇淫巧技/"}]},{"title":"JavaScript事件循环机制高级篇","slug":"EventLoopUp","date":"2017-04-09T11:33:07.000Z","updated":"2018-06-01T15:16:53.529Z","comments":true,"path":"2017/04/09/EventLoopUp/","link":"","permalink":"http://www.whbxyr.cn/2017/04/09/EventLoopUp/","excerpt":"","text":"&emsp;&emsp;在上一篇文章JavaScript事件循环机制入门篇当中，我们对JavaScript的事件循环机制进行了初步的了解，熟悉了JavaScript的函数调用栈以及任务队列的定义和作用，并指出JavaScript的任务队列分为宏任务(macro-task)和微任务(micro-task)两种，如下： 1.macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering 2.micro-task包括：process.nextTick, Promises, Object.observe(已废弃), MutationObserver(html5新特性) &emsp;&emsp;这篇文章里，我们就以一段测试代码来感受一下JavaScript事件循环机制的“复杂过程”。测试代码如下：（依然是借鉴的别人的例子）12345678910111213(function test() &#123; setTimeout(function () &#123;console.log(4)&#125;, 0); new Promise(function executor(resolve) &#123; console.log(1); for (var i = 0; i &lt; 10000; i++) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(2); &#125;).then(function () &#123; console.log(5); &#125;); console.log(3);&#125;)(); 1.首先，script任务源先执行，全局上下文入栈。2.script任务源的代码在执行时遇到setTimeout,作为一个macro-task，将其回调函数放入自己的队列之中。3.script任务源的代码在执行时遇到Promise实例。Promise构造函数中的第一个参数是在当前任务直接执行不会被放入队列之中，因此此时输出 1 。4.在for循环里面遇到resolve函数，函数入栈执行之后出栈，此时Promise的状态变成Fulfilled。代码接着执行遇到console.log(2),输出2。5.接着执行，代码遇到then方法，其回调函数作为micro-task入栈，进入Promise的任务队列之中。6.代码接着执行，此时遇到console.log(3),输出3。7.输出3之后第一个宏任务script的代码执行完毕，这时候开始开始执行所有在队列之中的micro-task。then的回调函数入栈执行完毕之后出栈，这时候输出58.这时候所有的micro-task执行完毕，第一轮循环结束。第二轮循环从setTimeout的任务队列开始，setTimeout的回调函数入栈执行完毕之后出栈，此时输出4。 总结 任务分宏任务和微任务两种，它们（回调函数）被放入不同的任务队列中。 对一段代码，先执行宏任务中的一个任务队列，等到这个任务队列中的函数从函数调用栈中清空时，再执行微任务。 等到所有的微任务执行完毕后，再从宏任务中的一个任务队列开始执行。 JavaScript事件循环机制就是按照以上3步循环执行的。 提问？&emsp;&emsp;如果在宏任务或者微任务里面再嵌套进去一个或者多个宏任务或者微任务，事件循环机制又是怎么处理的呢？比如以下测试代码的输出情况就有三种： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849console.log('glob1');setImmediate(function () &#123; console.log('immediate1'); process.nextTick(function () &#123; console.log('immediate1_nextTick'); &#125;); new Promise(function (resolve) &#123; console.log('immediate1_promise'); resolve(); &#125;).then(function () &#123; console.log('immediate1_then'); &#125;); setTimeout(function () &#123; console.log('immediate1_timeout1'); &#125;); setImmediate(function () &#123; console.log('immediate1_immediate1'); &#125;);&#125;);setTimeout(function () &#123; console.log('timeout1'); process.nextTick(function () &#123; console.log('timeout1_nextTick'); &#125;); new Promise(function (resolve) &#123; console.log('timeout1_promise'); resolve(); &#125;).then(function () &#123; console.log('timeout1_then'); &#125;); setTimeout(function () &#123; console.log('timeout1_timeout1'); process.nextTick(function () &#123; console.log('timeout1_timeout1_nextTick'); &#125;); setImmediate(function () &#123; console.log('timeout1_setImmediate1'); &#125;); &#125;);&#125;);new Promise(function (resolve) &#123; console.log('glob1_promise'); resolve();&#125;).then(function () &#123; console.log('glob1_then');&#125;);process.nextTick(function () &#123; console.log('glob1_nextTick');&#125;); 第一种输出情况：1234567891011121314151617glob1glob1_promiseglob1_nextTickglob1_thentimeout1timeout1_promisetimeout1_nextTicktimeout1_thenimmediate1immediate1_promiseimmediate1_nextTickimmediate1_thentimeout1_timeout1timeout1_timeout1_nextTickimmediate1_immediate1timeout1_setImmediate1immediate1_timeout1 第二种输出情况：1234567891011121314151617glob1glob1_promiseglob1_nextTickglob1_thentimeout1timeout1_promisetimeout1_nextTicktimeout1_thenimmediate1immediate1_promiseimmediate1_nextTickimmediate1_thenimmediate1_immediate1timeout1_timeout1immediate1_timeout1timeout1_timeout1_nextTicktimeout1_setImmediate1 第三种输出情况：1234567891011121314151617glob1glob1_promiseglob1_nextTickglob1_thentimeout1timeout1_promisetimeout1_nextTicktimeout1_thenimmediate1immediate1_promiseimmediate1_nextTickimmediate1_thentimeout1_timeout1immediate1_timeout1timeout1_timeout1_nextTickimmediate1_immediate1timeout1_setImmediate1 本人还不是特别理解这些情况，如果您了解的话，请不吝赐教！我的工作邮箱：**raywhbxyr@163.com** 参考资料深入浅出Javascript事件循环机制(上)深入浅出JavaScript事件循环机制(下)前端基础进阶（十二）：深入核心，详解事件循环机制JavaScript：彻底理解同步、异步和事件循环(Event Loop)","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"}]},{"title":"JavaScript事件循环机制入门篇","slug":"EventLoop","date":"2017-04-09T05:20:09.000Z","updated":"2018-06-01T15:16:53.513Z","comments":true,"path":"2017/04/09/EventLoop/","link":"","permalink":"http://www.whbxyr.cn/2017/04/09/EventLoop/","excerpt":"","text":"函数调用栈和任务队列&emsp;&emsp;Javascript有一个函数调用栈（call-stack），当在函数调用栈中执行某一个task时，其他的task都要等着，直到这个task执行完成并从函数调用栈中出栈（函数调用栈此时为空）时，下一个task才可以进入函数调用栈中执行。 &emsp;&emsp;而JavaScript是单线程的，当在执行过程中遇到一些类似于setTimeout等异步操作的时候，会交给浏览器的其他模块(以webkit为例，是webcore模块)进行处理，当到达setTimeout指定的延时执行的时间之后，task(回调函数)会放入到任务队列之中。不同的异步任务的回调函数会放入不同的任务队列之中，比如宏任务和微任务（如下所示）。两者中，前者为宏任务，后者为微任务，在事件循环中的执行顺序均为从左到右。 1.macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering 2.micro-task包括：process.nextTick, Promises, Object.observe(已废弃), MutationObserver(html5新特性) 等到函数调用栈中所有task执行完毕之后，接着去执行其它任务队列之中的task。下图展示了大致的执行流程以及结构：&emsp;&emsp;由上图可知，函数调用栈中遇到DOM操作/ajax请求或者setTimeout等WebAPIs的时候就会交给浏览器内核的其他模块进行处理，webkit内核在Javasctipt执行引擎之外，有一个重要的模块是webcore模块。对于图中WebAPIs提到的三种API，webcore分别提供了DOM Binding、network、timer模块来处理底层实现。等到这些模块处理完这些操作的时候将回调函数放入任务队列中，之后等栈中的task执行完之后再去执行以上任务队列之中的回调函数。 以setTimeout为例观察事件循环机制（借鉴别人的）1.首先main()函数的执行上下文入栈。2.代码接着执行，遇到console.log(‘Hi’),此时log(‘Hi’)入栈，console.log方法只是一个webkit内核支持的普通的方法，所以log(‘Hi’)方法立即被执行。此时输出’Hi’。3.当遇到setTimeout的时候，执行引擎将其添加到栈中。4.调用栈发现setTimeout是之前提到的WebAPIs中的API，因此将其出栈之后将延时执行的函数交给浏览器的timer模块进行处理。5.timer模块去处理延时执行的函数，此时执行引擎接着执行将log(‘SJS’)添加到栈中，此时输出’SJS’。6.当timer模块中延时方法规定的时间到了之后就将其放入到任务队列之中，此时调用栈中的task已经全部执行完毕。7.任务队列中的回调函数调入函数调用栈中执行。8.执行具体的内部程序。 总结&emsp;&emsp;本文简单讲解了JavaScript事件循环机制的原理，主要几点如下： &emsp;&emsp;1.所有的代码都要通过函数调用栈中调用执行。&emsp;&emsp;2.当遇到前文中提到的APIs的时候，会交给浏览器内核的其他模块进行处理。&emsp;&emsp;3.任务队列中存放的是回调函数。&emsp;&emsp;4.等到调用栈中的task执行完之后再回去执行任务队列之中的task。 &emsp;&emsp;本文只能算是入门，若想深入了解JavaScript的事件循环机制，可见我的下一篇文章JavaScript事件循环机制高级篇 参考资料深入浅出Javascript事件循环机制(上)深入浅出JavaScript事件循环机制(下)前端基础进阶（十二）：深入核心，详解事件循环机制JavaScript：彻底理解同步、异步和事件循环(Event Loop)","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"}]},{"title":"为hexo博客添加独立域名","slug":"hexoCname","date":"2017-04-04T05:07:04.000Z","updated":"2018-06-01T15:16:53.575Z","comments":true,"path":"2017/04/04/hexoCname/","link":"","permalink":"http://www.whbxyr.cn/2017/04/04/hexoCname/","excerpt":"","text":"一共需要两个步骤：1.添加一条CNAME记录，主机记录随便写（根据个人需要，比如www，url便为www.域名.根域名），记录值为你的github page的地址，比如我的就是whbxyr.github.io。如下图：2.在你放置hexo博客的github仓库的Settings里设置Custom domain，设置为你要的url，比如我的就是www.whbxyr.cn，如下图： 或者在你的本地hexo博客目录下的source文件夹里添加一个文件，文件名为CNAME，在其中输入你的域名，比如我的就是www.whbxyr.cn，如下图：","categories":[{"name":"技术类-奇淫巧技","slug":"技术类-奇淫巧技","permalink":"http://www.whbxyr.cn/categories/技术类-奇淫巧技/"}],"tags":[{"name":"奇淫巧技","slug":"奇淫巧技","permalink":"http://www.whbxyr.cn/tags/奇淫巧技/"}]},{"title":"Ubuntu下彻底卸载软件的方法","slug":"aptRemove","date":"2017-04-03T10:14:15.000Z","updated":"2018-06-01T15:16:53.560Z","comments":true,"path":"2017/04/03/aptRemove/","link":"","permalink":"http://www.whbxyr.cn/2017/04/03/aptRemove/","excerpt":"","text":"在介绍一般的彻底卸载软件的命令前，先介绍一些卸载命令的作用1.删除软件包（保留配置文件），但不删除该软件依赖的包1$ sudo apt-get remove &lt;package&gt; 2.删除软件包（不保留配置文件），但不删除该软件依赖的包1$ sudo apt-get --purge remove &lt;package&gt; 3.删除软件后再删除依赖包（保留配置文件）1$ sudo apt-get autoremove &lt;package&gt; 4.删除 /var/cache/apt/archives/ 已经过期的deb1$ sudo apt-get autoclean &lt;package&gt; 5.删除 /var/cache/apt/archives/ 中所有的deb1$ sudo apt-get clean 一般彻底卸载软件的命令及使用顺序如下123456// 删除软件及其配置文件$ sudo apt-get --purge remove &lt;package&gt;// 删除已经不再依赖的软件依赖包$ sudo apt-get autoremove &lt;package&gt;// 删除此时dpkg列表中有“rc”状态的软件包$ sudo dpkg -l | grep ^rc | awk '&#123;print $2&#125;' | sudo xargs dpkg -P","categories":[{"name":"技术类-linux","slug":"技术类-linux","permalink":"http://www.whbxyr.cn/categories/技术类-linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://www.whbxyr.cn/tags/ubuntu/"}]},{"title":"es6(一) 之 let 和 const 命令","slug":"letncst","date":"2016-12-26T06:27:31.000Z","updated":"2018-06-01T15:16:53.575Z","comments":true,"path":"2016/12/26/letncst/","link":"","permalink":"http://www.whbxyr.cn/2016/12/26/letncst/","excerpt":"","text":"（一）let命令以及块级作用域(1) let命令声明的变量只在所在的代码块内有效(2) for循环的循环语句是一个父级作用域，而循环体内部是一个单独的子作用域(3) for循环的每次循环中的变量i都是重新声明的，作用域之间无关系(4) 不存在声明提前，在声明之前使用变量会报错“ReferenceError: i is not defined”(5) 存在暂时性死区，只要块级作用域内存在let命令，它所声明的变量就”绑定“（binding）这个区域，不再受外部的影响。 因为“暂时性死区”的存在，使得typeof不再是一个百分之百安全的操作12typeof x; // ReferenceErrorlet x; // 在x声明之前，都属于x的死区，只要用到该变量就会报错 (6) 不允许重复声明。let不允许在相同作用域内，重复声明同一个变量。let、var以及const三者是不允许在相同作用域内声明同一个变量的。123456789101112131415161718192021// 报错function () &#123; let a = 10; var a = 1;&#125;// 报错function () &#123; let a = 10; let a = 1;&#125;function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; (7) ES6 块级作用域的实现实际上使得广泛应用的立即执行函数表达式（IIFE）不再必要了。1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; (8) 块级作用域与函数声明。 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域中声明。但是浏览器为了兼容以前的旧代码，还是支持在块级作用域之中声明函数。 ES6 引入了块级作用域，明确允许在块级作用域中声明函数，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。但是为了减轻因此产生的不兼容问题，ES6 在附录B中规定： 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。 以上三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当左let处理。1234567891011121314151617181920212223242526// 浏览器的 ES6 环境function f() &#123; console.log('I am outside!');&#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f(); // Uncaught TypeError: f is not a function&#125;())// 相当于(function () &#123; var f = undefined; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f(); // Uncaught TypeError: f is not a function&#125;()) (9) 另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。12345678910// 不报错'use strict';if (true) &#123; function f() &#123;&#125;&#125;// 报错'use strict';if (true) function f() &#123;&#125; （二）const命令(1) const 命令除了不适用于循环之外，拥有let 命令的所有特性。(2) const 本质上并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。12345678910111213141516171819const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: \"foo\" is read-onlyconst a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错// 如果真的想将对象冻结，应该使用Object.freeze方法。const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; (3) 以下展示的是将一个对象彻底冻结的函数。12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;;","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"},{"name":"es6","slug":"es6","permalink":"http://www.whbxyr.cn/tags/es6/"}]},{"title":"利用tinymce编写网页文章并插入到MySQL数据库","slug":"tinymce-MySQL","date":"2016-10-04T10:23:22.000Z","updated":"2018-06-01T15:16:53.591Z","comments":true,"path":"2016/10/04/tinymce-MySQL/","link":"","permalink":"http://www.whbxyr.cn/2016/10/04/tinymce-MySQL/","excerpt":"","text":"tinymce是一个轻量级的基于浏览器的所见即所得编辑器，由JavaScript写成。以下我将为大家介绍如何使用JavaScript的Ajax、配合使用php将tinymce中编写的文章经过转码后顺利存储进MySQL数据库。（将文章数据库表设计为只有两个字段，一个是int型的自增长id字段，另一个是text类型的article字段） 第一步：在你的网站根目录（或者其他网站目录也行）下新建一个editor.html文件，编辑代码如下：1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;tinymce编辑文章&lt;/title&gt; &lt;script src=\"http://cdn.tinymce.com/4/tinymce.min.js\"&gt;&lt;script&gt; &lt;script src=\"./event.js\"&gt;&lt;/script&gt; &lt;script src=\"./htmlcode.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;textarea id=\"editor\" name=\"content\"&gt;&lt;/textarea&gt; &lt;input id=\"handin\" type=\"button\" value=\"提交\"&gt;&lt;/body&gt;&lt;/html&gt; 这个文件将tinymce文章编辑器插件成功应用到我们的页面当中,并添加了一个用于提交文章到数据库的“提交”按钮。 其中引入的event.js文件代码如下，应将其置于同一目录下。它是一个为DOM添加事件处理的兼容脚本。1234567891011121314151617/** * 为DOM添加事件处理的兼容脚本 * /var EventUtil = &#123; // 添加句柄 addHandler: function (element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent('on'+type, handler); &#125; else &#123; element['on'+type] = handler; &#125; &#125;&#125; 其中引入的htmlcode.js文件代码如下，同样将其置于editor.html同一目录下。它是一个实现html转码的脚本。1234567891011121314151617181920212223242526/** * 用浏览器内部转换器实现 * javascript处理HTML的Encode(转码)和Decode(解码) */var HtmlUtil = &#123; // 用浏览器内部转换器实现html转码 // 首先动态创建一个容器标签元素，如DIV， // 然后将要转换的字符串设置为这个元素的innerText(ie支持) // 或者textContent(火狐，google支持)，最后返回这个元素的innerHTML， // 即得到经过HTML编码转换的字符串了。 htmlEncode: function (html) &#123; var div = document.createElement('div'); div.appendChild(document.createTextNode(html)); return div.innerHTML; &#125;, // 用浏览器内部转换器实现html解码 // 首先动态创建一个容器标签元素，如DIV， // 然后将要转换的字符串设置为这个元素的innerHTML(ie，火狐，google都支持)， // 最后返回这个元素的innerText(ie支持)或者textContent(火狐，google支持)， // 即得到经过HTML解码的字符串了。 htmlDecode: function (text) &#123; var div = document.createElement('div'); div.innerHTML = text; return div.innerText || div.textContent; &#125; &#125; 第二步：将以下代码插入到editor.html文件的底部，其实就是一些用script标签包起来的JavaScript代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344EventUtil.addHandler(document.getElementById('handin'), 'click', function () &#123; // 创建一个XMLHttpRequest对象 var request = new XMLHttpRequest(); // 对articleToDB.php文件发出POST请求 request.open('POST', './articleToDB.php'); // ajax传过去的参数都会被处理为字符串，因此不需要再将参数转换为字符串 // 先进行“去\\n”操作，再进行html编码，使用的是浏览器内部转换器 var article = HtmlUtil.htmlEncode((tinyMCE.activeEditor.getContent()).replace(/[\\n]/ig, '')); // tinyMCE.activeEditor.getContent()方法会在我们写的文章里面的每一个\\前再加一个\\ // 当我们在文章里只写了一个\\时， // tinyMCE.activeEditor.getContent()方法给我们多加了一个\\ // 此时就有了两个\\，但是正则表达式不会匹配第一个作为转义字符作用的反斜杠'\\'， // 在用正则表达式匹配字符串时，转义符相当于不存在 // 因此在这里用正则匹配时就只需要4个转义符 // 用replace()方法将其替换为4个\\ // 即符合mysql数据库3个转义符转义一个字符的规则 article = article.replace(/\\\\/g, '\\\\\\\\'); // 将获取的html代码中的\"替换为\\\\\\\" // 这样ajax才能正确读取参数并将其完整插入数据库 article = article.replace(/[\"]/g, '\\\\\\\"'); // 对处理完的字符串进行最终的编码，去除取值符等敏感字符对ajax传值的影响 article = encodeURIComponent(article); // 拼接请求主体 var data = 'article=' + article; // POST请求方式必须设置的请求头格式 request.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); request.send(data); request.onreadystatechange = function () &#123; if (request.readyState === 4) &#123; if (request.status === 200) &#123; // 弹出相关文字提示 alert(request.responseText); &#125; else &#123; // 当请求不到数据时就会导致错误，用以下方法显示 alert('发生错误：' + request.status); &#125; &#125; &#125;&#125;); 第三步：编写articleToDB.php文件实现文章插入MySQL数据库，并将其置于editor.html同一目录下。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phpheader('Content-Type: application/json; charset=utf-8');// 若取不到值，那么进行相应的信息反馈并结束if (!isset($_POST['article']) || empty($_POST['article'])) &#123; echo '您还没有编辑文章'; exit;&#125;// 面向对象的建立数据库连接的方法// 应该填写服务器数据库的主机名，用户名以及相对应的密码// 比如$db = new mysqli('localhost','root','123456789');$db = new mysqli('主机名','用户名','密码');if (mysqli_connect_errno()) &#123; echo '连接数据库失败，请稍后重试！'; exit;&#125;// 判断数据库是否存在$select = $db-&gt;select_db('article');if (!$select) &#123; // 创建数据库失败后的处理提示 $createDB_query = 'create database article'; $createDB = $db-&gt;query($createDB_query); if (!$createDB) &#123; echo '创建数据库失败'; exit; &#125; //使用数据库失败后的处理提示 $useDB_query = 'use article'; $useDB = $db-&gt;query($useDB_query); if (!$useDB) &#123; echo '使用数据库失败'; exit; &#125; else &#123; echo '成功'; exit; &#125;&#125;// 设置数据库编码$db-&gt;query('set names utf8');// 此处在接收到经过编码的article后，通过=操作符，实现了解码$article = $_POST['article'];$insert_query = 'insert into text2 values(NULL, \"'.$article.'\")';$insert_result = $db-&gt;query($insert_query);// 对返回结果进行判断if ($insert_result) &#123; echo '成功！管理员文章发布成功！';&#125;else &#123; echo '失败！管理员文章发布失败！';&#125;// 关闭数据库连接$db-&gt;close(); 以上三步便是利用JavaScript的Ajax、配合使用php将tinymce中编写的文章经过转码后顺利存储进MySQL数据库的全过程，需要注意的点有以下几个： 1. html代码必须经过转码后才能插入数据库; 2. 字符串’\\\\’长度为1而不是2; 3. 正则表达式匹配字符串时并不匹配起转义字符作用的反斜杠’\\’; 4. 在插入MySQL数据库时，3个转义字符转义一个字符","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://www.whbxyr.cn/tags/插件/"}]},{"title":"兼容浏览器的事件处理程序 EventUtil","slug":"EventUtil","date":"2016-06-24T10:06:56.000Z","updated":"2018-06-01T15:16:53.544Z","comments":true,"path":"2016/06/24/EventUtil/","link":"","permalink":"http://www.whbxyr.cn/2016/06/24/EventUtil/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113var EventUtil = &#123; // 获取事件对象，兼容IE getEvent: function (event) &#123; return event ? event : window.event; &#125;, // 获取事件目标，兼容IE getTarget: function (event) &#123; return event.target || event.srcElement; &#125;, // 阻止默认事件，兼容IE preventDefault: function (event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 阻止事件冒泡，兼容IE stopPropagation: function (event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;, // 注册事件 addHandler: function (element, type, handler) &#123; if (element.addEventListener) &#123; // DOM2级的事件处理程序，最后一个参数为false，设置该事件处理程序在事件流的冒泡阶段触发 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent)&#123; // IE的事件处理程序 element.attachEvent('on' + type, handler); &#125; else &#123; // DOM0级的事件处理程序 element['on' + type] = handler; &#125; &#125;, // 删除事件 removeHandler: function (element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent('on' + type, handler); &#125; else &#123; element['on' + type] = null; &#125; &#125;, // 获取事件(mouseover, mouseout)相关元素的信息 getRelatedTarget: function (event) &#123; if (event.relatedTarget) &#123; return event.relatedTarget; &#125; else if (event.toElement) &#123; return event.toElement; &#125; else if (event.fromElement) &#123; return event.fromElement; &#125; else &#123; return null; &#125; &#125;, // 获取鼠标点击事件的鼠标按钮 getButton: function (event) &#123; if (document.implementation.hasFeature('MouseEvents', '2.0')) &#123; return event.button; &#125; else &#123; switch (event.button) &#123; case 0: case 1: case 3: case 5: case 7: // 返回0表示主鼠标按钮 return 0; case 2: case 6: // 返回2表示次鼠标按钮 return 2; case 4: // 返回1表示中间的鼠标按钮 return 1; &#125;; &#125; &#125;, // 获取mousewheel事件的wheelDelta或者detail属性 getWheelDelta: function (event) &#123; if (event.wheelDelta) &#123; return (client.engine.opera &amp;&amp; client.engine.opera &lt; 9.5 ? -event.wheelDelta : event.wheelDelta); &#125; else &#123; return -event.detail * 40; &#125; &#125;, // 获取键盘事件的字符编码 getCharCode: function (event) &#123; if (typeof event.charCode === 'number') &#123; return event.charCode; &#125; else &#123; return event.keyCode; &#125; &#125;&#125;;","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"},{"name":"DOM","slug":"DOM","permalink":"http://www.whbxyr.cn/tags/DOM/"}]},{"title":"异步加载 javascript 文件的方法总结","slug":"asyncJs","date":"2016-04-28T14:36:51.000Z","updated":"2018-06-01T15:16:53.560Z","comments":true,"path":"2016/04/28/asyncJs/","link":"","permalink":"http://www.whbxyr.cn/2016/04/28/asyncJs/","excerpt":"","text":"异步加载 javascript 文件的方法","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"}]},{"title":"事件流概述","slug":"event","date":"2016-04-24T09:38:56.000Z","updated":"2018-06-01T15:16:53.560Z","comments":true,"path":"2016/04/24/event/","link":"","permalink":"http://www.whbxyr.cn/2016/04/24/event/","excerpt":"","text":"&emsp;&emsp;事件流描述的是从页面中接收事件的顺序，而 IE 和 Netscape 提出了差不多是完全相反的事件流的概念。IE 的事件流是事件冒泡，而 Netscape Communicator 的事件流是事件捕获。 IE的事件冒泡&emsp;&emsp;事件冒泡，即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。以下面的页面为例：123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Event Bubbling Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"myDiv\"&gt;Click Me&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; &emsp;&emsp;如果你单击了页面中的&lt;div&gt;元素，那么这个click事件会按照如下顺序传播：(1) &lt;div&gt;(2) &lt;body&gt;(3) &lt;html&gt;(4) document&emsp;&emsp;IE5.5 及更早的版本中的事件冒泡会跳过&lt;html&gt;元素（从&lt;body&gt;直接跳到document）。IE9、Firefox、Chrome 和 Safari 则将事件一直冒泡到 window 对象。 事件捕获&emsp;&emsp;事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件达到预定目标之前捕获它。如果仍以前面的HTML页面作为例子，那么单击&lt;div&gt;元素就会以下列顺序触发 click 事件：(1) document(2) &lt;html&gt;(3) &lt;body&gt;(4) &lt;div&gt;&emsp;&emsp;虽然事件捕获是 Netscape Communicator 唯一支持的事件流模型，但 IE9、Safari、Chrome、Opera 和 Firefox 目前也都支持这种事件流模型。尽管“DOM2级事件”规范要求事件应该从 document 对象开始传播，但这些浏览器都是从 window 对象开始捕获事件的。 由于老版本的浏览器不支持，因此很少有人使用事件捕获，建议使用事件冒泡，在有特殊需要的时候再使用事件捕获。DOM 事件流&emsp;&emsp;“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。它们的发生顺序如下：(1) 事件捕获，为截获事件提供了机会，这一过程不会传播到实际的事件目标(2) 实际的目标接收到事件，于是事件在此目标上发生，并在事件处理中被看成冒泡阶段的一部分(3) 冒泡阶段，可以在这个阶段对事件做出响应，然后事件又传播回文档。&emsp;&emsp;仍以前面的HTML页面作为例子，DOM2级事件流如下图： 事件处理程序：&emsp;&emsp;事件处理程序分HTML事件处理程序、DOM0级事件处理程序、DOM2级事件处理程序、IE事件处理程序四种。为了兼容各种浏览器，也催生出了跨浏览器的事件处理程序。 HTML事件处理程序&emsp;&emsp;示例如下：123456&lt;script&gt;function showMsg() &#123; alert('Hello world!');&#125;&lt;/script&gt;&lt;input type=\"button\" value=\"Click Me\" onclick=\"showMsg()\"&gt; DOM0级事件处理程序&emsp;&emsp;示例如下：12345var btn = document.getElementById('myBtn');btn.onclick = function () &#123; // 弹出“myBtn” alert(this.id);&#125; DOM2级事件处理程序&emsp;&emsp;示例如下：1234567var btn = document.getElementById('myBtn');var handler = function () &#123; alert(this.id);&#125;;btn.addEventListener('click', handler, false);// 指定事件处理程序的名称才能实现移除事件处理程序btn.removeEventListener('click', handler, false); IE事件处理程序&emsp;&emsp;示例如下：1234567var btn = document.getElementById('myBtn');var handler = function () &#123; alert(‘Clicked’);&#125;;btn.attachEvent('onclick', handler);// 指定事件处理程序的名称才能实现移除事件处理程序btn.detachEvent('onclick', handler); 跨浏览器的事件处理程序&emsp;&emsp;既然事件处理程序在不同浏览器上的实现方式不一样，那么能够跨浏览器的事件处理程序的存在就十分重要。关于跨浏览器的事件处理程序，可以观看我的另一篇文章——兼容浏览器的事件处理程序 EventUtil！ 总结在使用事件时，需要考虑如下一些内存与性能方面的问题。1.有必要限制一个页面中事件处理程序的数量，数量太多会导致占用大量内存，而且也会让用户感觉页面反应不够灵敏。2.建立在事件冒泡机制之上的事件委托技术，可以有效地减少事件处理程序的数量。3.建议在浏览器卸载页面之前移除页面中的所有事件处理程序。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"},{"name":"DOM","slug":"DOM","permalink":"http://www.whbxyr.cn/tags/DOM/"}]},{"title":"清除子元素浮动造成的影响","slug":"clearFloat","date":"2016-04-22T02:21:34.000Z","updated":"2018-06-01T15:16:53.560Z","comments":true,"path":"2016/04/22/clearFloat/","link":"","permalink":"http://www.whbxyr.cn/2016/04/22/clearFloat/","excerpt":"","text":"第一种：父级div设置高度12345678910111213&lt;style&gt;.father &#123; height: 200px;&#125;.son &#123; float: left; width: 20%; height: 200px;&#125;&lt;/style&gt;&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;浮动元素&lt;/div&gt;&lt;/div&gt; 第二种：父级内部结尾处添加空的clear: both的div标签1234567891011121314&lt;style&gt;.son &#123; float: left; width: 20%; height: 200px;&#125;.clearfloat &#123; clear: both;&#125;&lt;/style&gt;&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;浮动元素&lt;/div&gt; &lt;div class=\"clearfloat\"&gt;&lt;/div&gt;&lt;/div&gt; 第三种：父级使用伪类，类似第二种方法1234567891011121314151617181920&lt;style&gt;.father &#123; *zoom: 1;&#125;.father:after &#123; content: ''; display: block; clear: both; height: 0; overflow: hidden;&#125;.son &#123; float: left; width: 20%; height: 200px;&#125;&lt;/style&gt;&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;&lt;/div&gt;&lt;/div&gt; 或者使用下面的方法，也是使用了伪类123456789101112131415161718&lt;style&gt;.father &#123; *zoom: 1;&#125;.father:after &#123; content: ''; display: table; clear: both;&#125;.son &#123; float: left; width: 20%; height: 200px;&#125;&lt;/style&gt;&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;&lt;/div&gt;&lt;/div&gt; 第四种：给父级添加overflow: hidden/auto/scroll;、float: left/right;、position: absolute;、display: inline-block;、zoom: 1;五个CSS属性其中之一1234567891011121314151617&lt;style&gt;.father &#123; overflow: hidden/auto/scroll; /*float: left/right;*/ /*position: absolute;*/ /*display: inline-block;*/ /*zoom: 1;*/&#125;.son &#123; float: left; width: 20%; height: 200px;&#125;&lt;/style&gt;&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;&lt;/div&gt;&lt;/div&gt;","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"html","slug":"html","permalink":"http://www.whbxyr.cn/tags/html/"},{"name":"css","slug":"css","permalink":"http://www.whbxyr.cn/tags/css/"}]},{"title":"DOM详解","slug":"DOM","date":"2016-04-20T12:32:42.000Z","updated":"2018-06-01T15:16:53.513Z","comments":true,"path":"2016/04/20/DOM/","link":"","permalink":"http://www.whbxyr.cn/2016/04/20/DOM/","excerpt":"","text":"&emsp;&emsp;文档节点是每个文档的根节点，文档节点只有一个子节点，即&lt;html&gt;元素，我们称之为文档元素。文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。在HTML页面中，文档元素始终都是&lt;html&gt;元素。在XML中，没有预定义的元素，因此任何元素都可能成为文档元素。 &emsp;&emsp;接下来讲讲Node类型。DOM1级定义了一个Node接口，该接口将由DOM中的所有节点类型实现。这个Node接口在JavaScript中是作为Node类型实现的；除IE之外，在其他所有浏览器中都可以访问到这个类型。JavaScript中的所有节点类型都继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。每个节点都有一个nodeType属性，共有12种节点类型，每种类型都由Node类型中定义的一个数值常量来表示，如下：123456789101112Node.ELEMENT_NODE(1)Node.ATTRIBUTE_NODE(2)Node.TEXT_NODE(3)Node.CDATA_SECTION_NODE(4)Node.ENTITY_REFERENCE_NODE(5)Node.ENTITY_NODE(6)Node.PROCESSING_INSTRUCTION_NODE(7)Node.COMMENT_NODE(8)Node.DOCUMENT_NODE(9)Node.DOCUMENT_TYPE_NODE(10)Node.DOCUMENT_FRAGMENT_NODE(11)Node.NOTATION_NODE(12)","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"},{"name":"DOM","slug":"DOM","permalink":"http://www.whbxyr.cn/tags/DOM/"},{"name":"html","slug":"html","permalink":"http://www.whbxyr.cn/tags/html/"}]},{"title":"iframe的优缺点","slug":"iframe","date":"2016-04-15T13:00:59.000Z","updated":"2018-06-01T15:16:53.575Z","comments":true,"path":"2016/04/15/iframe/","link":"","permalink":"http://www.whbxyr.cn/2016/04/15/iframe/","excerpt":"","text":"iframe的优点 iframe能够将嵌入的网页原封不动地显示出来 用iframe来实现具有统一风格的网页（相同的头部、底部） 修改方便，多个网页引用iframe，修改一处实现全部修改 iframe的缺点 iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差 搜索引擎的检索程序无法解读这种页面，不利于SEO iframe会阻塞主页面的Onload事件 会影响页面的并行加载，解决方法是使用js动态给iframe的src加载页面内容，示例代码如下：1234&lt;iframe id=\"iframe\"&gt;&lt;/iframe&gt;&lt;script&gt;document.getElementById(\"iframe\").src = \"a2.html\";&lt;/script&gt;","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"html","slug":"html","permalink":"http://www.whbxyr.cn/tags/html/"}]},{"title":"排序算法总结","slug":"sortAlgorithm","date":"2016-04-02T05:19:03.000Z","updated":"2018-06-01T15:16:53.591Z","comments":true,"path":"2016/04/02/sortAlgorithm/","link":"","permalink":"http://www.whbxyr.cn/2016/04/02/sortAlgorithm/","excerpt":"","text":"各大排序算法综合总结 详解中包括了时间复杂度（最差/平均/最优），面试宝典 算法 最差 平均 最优 空间 稳定性 直接插入排序 O(n^2) O(n^2) O(n) O(1) 稳定 希尔排序 O(nlogn) O(nlogn) 视情况而定 O(1) 不稳定 基数排序 O(d(n+r)) O(d(n+r)) O(d(n+r)) O(n+r) 稳定 快速排序 O(n^2) O(nlogn) O(nlogn) O(nlogn) 不稳定 选择排序 O(n^2) O(n^2) O(n^2) O(1) 不稳定 冒泡排序 O(n^2) O(n^2) O(n) O(1) 稳定 桶排序 O(n) O(n) O(n) max 稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(1) 稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定 这些都是面试的时候比较经常问的排序算法，有错误可以发邮件给我！","categories":[{"name":"技术类-算法","slug":"技术类-算法","permalink":"http://www.whbxyr.cn/categories/技术类-算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.whbxyr.cn/tags/算法/"}]},{"title":"《读大学，究竟读什么？》（覃彪喜）读后感","slug":"whatUniversity","date":"2015-07-18T08:55:02.000Z","updated":"2018-06-01T15:16:53.607Z","comments":true,"path":"2015/07/18/whatUniversity/","link":"","permalink":"http://www.whbxyr.cn/2015/07/18/whatUniversity/","excerpt":"","text":"《读大学，究竟读什么？》（覃彪喜）读后感&emsp;&emsp;《读大学，究竟读什么？》——到了大一结束时的现在才读完这本书的我，深深地感受到了以后求职的艰难！读大学真的就会有优势吗？在读完覃彪喜的这本书后，我知道，读大学可以有优势，但条件是在大学期间要好好学习！然而，能否充分利用这些优势，还是另外一个问题。 &emsp;&emsp;覃彪喜开门见山大谈“读大学，究竟读什么”，并得出读大学不是读技校，而是“读大师，读图书馆，读同学”的过程的结论。紧接着一一论述大学生在学习生涯以及毕业后求职生涯中可能出现以及应该注意的问题，并依据此思路将全书分为了18个章节。 &emsp;&emsp;其中，令我印象最深刻的是“做事不如做人，人脉决定成败”这一章。一个人本身的知识、文化、技术水平确实对个人的就业及事业发展起着很大作用，但是，人脉对一个人的发展也产生着足够大的不容小觑的影响，有时甚至起着决定性的作用。书中覃彪喜形象地将“人脉”比作“木桶效应”中的桶底，没有了桶底，一切努力都将付之东流。这一比喻或许太过极端，然而它却时刻警告着我们人脉之重要性！如果我们连社交能力都存在问题，那想在社会上很好地立足就不会太容易了，更别说要干出一番事业了。 &emsp;&emsp;书中作者对于大学生毕业后就业问题的描述也是极其详细。毕业后大学生遇到了很多问题，有的“病急乱投医”，有的盲目创业，这些问题都是普遍存在的。覃彪喜鼓励大学生“骑驴找马”，即先找一份或许不是很让人满意的工作，从经验中学习工作、就业方法，待自己成熟后，再去找自己真正意义上的第一份工作！这何尝不是一种就业的好方法呢！ &emsp;&emsp;作为即将步入大二的我，看完这本书后，最大的感触就是要珍惜当前，毕竟韶光易逝，若不好好趁现在装备自己，以后就只能是师弟师妹们眼中的失败案例！","categories":[{"name":"文学类","slug":"文学类","permalink":"http://www.whbxyr.cn/categories/文学类/"}],"tags":[{"name":"文学","slug":"文学","permalink":"http://www.whbxyr.cn/tags/文学/"}]},{"title":"ajax 的兼容使用方法","slug":"ajax","date":"2015-04-18T05:45:07.000Z","updated":"2018-06-01T15:16:53.560Z","comments":true,"path":"2015/04/18/ajax/","link":"","permalink":"http://www.whbxyr.cn/2015/04/18/ajax/","excerpt":"","text":"简介&emsp;&emsp;Ajax技术的核心是XMLHttpRequest对象（简称XHR对象），这是由微软首先引入的一个特性。Ajax是对Asynchronous JavaScript + XML的简写，但Ajax通信与数据格式无关，这种技术是无须刷新页面即可从服务器取得数据，但不一定是XML数据。 &emsp;&emsp;IE5是第一款引入XHR对象的浏览器。在IE5中，XHR对象是通过MSXML库中的一个ActiveX对象实现的。因此，在IE中可能会遇到三种不同版本的XHR对象，即MSXML2.XMLHttp、MSXML2.XMLHttp.3.0、MSXML2.XMLHttp.6.0。因此，为了兼容浏览器IE 6-，必须写一个函数去根据IE中可用的MSXML库的情况创建最新版本的XHR对象。 &emsp;&emsp;而 IE 7+、Firefox、Opera、Chrome 和 Safari 都支持原生的XHR对象，在这些浏览器中创建XHR对象要像下面这样使用XMLHttpRequest构造函数。1var xhr = new XMLHttpRequest(); 兼容函数createXHR12345678910111213141516171819202122232425function createXHR() &#123; if (typeof XMLHttpRequest !== 'undefined') &#123; return new XMLHttpRequst(); &#125; else if (typeof ActiveXObject !== 'undefined') &#123; if (typeof arguments.callee.activeXString !== 'string')&#123; var versions = ['MSXML2.XMLHttp', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp.6.0']; var i, len; for (var i = 0, len = versions.length; i &lt; len; i++) &#123; try &#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex) &#123; // 跳过 &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXObject); &#125; else &#123; throw new Error('No XHR object available'); &#125;&#125; &emsp;&emsp;这个函数首先检测原生XHR对象是否存在，如果它存在则返回它的新实例，否则检测ActiveXObject对象。如果这两种对象都不存在，就抛出一个错误。然后，就可以使用下面的代码在所有的浏览器中创建XHR对象了。1var xhr = createXHR(); XHR的具体使用方法&emsp;&emsp;XHR对象的通用使用方法如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var xhr = createXHR();// 异步的ajax请求可以检测XHR对象的readyState属性，该属性表示请求/响应过程的当前活动阶段// 0：未初始化。刚创建XHR对象，尚未调用open()方法// 1：启动。已经调用open()方法，但尚未调用send()方法// 2：发送。已经调用send()方法，但尚未接收到响应// 3：接收。已经接收到部分响应数据// 4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; // 服务器响应的数据会自动填充XHR对象的属性，相关的属性如下： // responseText：作为响应主体被返回的文本 // responseXMl：如果响应的内容类型是“text/xml”或“application/xml”，这个属性中将保存包含着响应数据的 XML DOM 文档 // status：响应的 HTTP 状态 // statusText：HTTP 状态的说明 alert(xhr.responseText); // 调用getResponseHeader()或者getAllResponseHeaders()可以取得相应的响应头部信息 var myHeader = xhr.getResponseHeader('MyHeader'); var allHeaders = xhr.getAllResponseHeaders(); &#125; else &#123; alert('Request was unsuccessful: ' + xhr.status); &#125; &#125;&#125;;// 查询字符串中每个参数的键和值都必须使用encodeURIComponent()进行编码才追加到URL末尾function addURLParam(url, name, value) &#123; url += (url.indexOf('?') === -1 ? '?' : '&amp;'); url += encodeURIComponent(name) + '=' + encodeURIComponent(value); return url;&#125;var url = 'example.php';// 添加参数url = addURLParam(url, 'name', 'Ray');url = addURLParam(url, 'book', 'Green Story');// 第一个参数可为“get”、“post”等// 第三个参数为true表示ajax请求为异步的，否则为同步的xhr.open('get', url, true);// 若要调用setRequestHeader()方法，必须在open()之后，send()之前xhr.setRequestHeader('MyHeader', 'MyValue');xhr.send(null);// 在接收到响应之前还可以调用abort()方法取消异步请求// xhr.abort();// 以上使用的是get的提交方式，以下以一个post提交方式的ajax请求来模拟表单提交xhr.open('post', 'postexample.php', true);// 使用post提交方式必须声明这个头部，表示表单提交时的内容类型xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');var form = document.getElementById('user-info');// 序列化页面中的“表单数据”并发送xhr.send(serialize(form)); 总结 负责Ajax运作的核心对象是XMLHttpRequest（XHR）对象。 XHR对象由微软最早在IE5中引入，用于通过JavaScript从服务器取得XML数据。 在此之后，Firefox、Safari、Chrome 和 Opera都是实现了相同的特性，使XHR成为了Web的一个事实标准。 虽然实现之间存在差异，但XHR对象的基本使用方法在不同浏览器间还是相对规范的，因此可以放心地用在Web开发当中。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"},{"name":"ajax","slug":"ajax","permalink":"http://www.whbxyr.cn/tags/ajax/"}]},{"title":"详解 JSON 以及 JSON 在JS中的使用","slug":"json","date":"2015-03-16T08:03:50.000Z","updated":"2018-06-01T15:16:53.575Z","comments":true,"path":"2015/03/16/json/","link":"","permalink":"http://www.whbxyr.cn/2015/03/16/json/","excerpt":"","text":"简介&emsp;&emsp;JSON是一种数据结构而不是一种编程语言，它利用了JS中的一些模式来表示结构化数据，虽然与JS具有相同的语法形式，但是JSON并不从属于JS。另外，并不是只有JS才使用JSON，很对编程语言都有针对JSON的解析器和序列化器。 JSON的语法一. 取值类型&emsp;&emsp;简单值： 可以在JSON中表示字符串、数值、布尔值和null，但不支持特殊值undefined。&emsp;&emsp;对象： 复杂数据类型，表示一组无序的键值对，每个键值对中的值可以是简单值，也可以是复杂数据类型的值。&emsp;&emsp;数组： 复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值，该值也可以是简单值、对象或者数组。 二. 语法&emsp;&emsp;JSON没有变量的概念，末尾没有分号，属性必须加双引号，举例如下：12345678&#123; \"name\": \"Ray\", \"age\": 20, \"school\": &#123; \"name\": \"GDUT\", \"location\": \"CHINA\" &#125;&#125; &emsp;&emsp;JSON数组：12345678910111213141516171819202122232425262728293031// 示例一[20, \"hi\", true]// 示例二[ &#123; \"title\": \"Story One\", \"authors\": [ \"Ray\" ], \"edition\": 3, \"year\": 2017 &#125;, &#123; \"title\": \"Story Two\", \"authors\": [ \"Tom\" ], \"edition\": 2, \"year\": 2016 &#125;, &#123; \"title\": \"Story Three\", \"authors\": [ \"Amy\", \"Sara\", \"Jack\" ], \"edition\": 4, \"year\": 2014 &#125;] 解析与序列化&emsp;&emsp;ECMAScript 5对解析JSON的行为进行规范，定义了全局对象JSON，支持这个对象的浏览器有 IE 8+、Firefox 3.5+、Safari 4+、Chrome 和 Opera 10.5+。对于较早的、不能原生支持JSON解析的浏览器，可以使用一个shim：https://github.com/douglascrockford/JSON-js，这比使用eval()对JSON数据结构求值要安全，避免了一些恶意代码的执行。 一. 序列化&emsp;&emsp;JSON.stringify()用于将JS对象序列化为JSON字符串。在序列化JS对象时，所有函数及原型成员都会被有意忽略，不体现在结果中，此外，值为undefined的任何属性也会被跳过。举例如下：12345678910var book = &#123; title: \"Story One\", authors: [ \"Ray\" ], edition: 3, year: 2017&#125;;var jsonText = JSON.stringify(book);// jsonText中的字符串： &#123;\"title\":\"Story One\",\"authors\":[\"Ray\"],\"edition\":3,\"year\":2017&#125; &emsp;&emsp;JSON.stringify()还可以另外接收两个可选的参数，第一个参数是个过滤器，值为一个数组或者一个函数，举例如下：12345678910111213141516171819202122232425var book = &#123; \"title\": \"Story One\", \"authors\": [ \"Ray\" ], edition: 3, year: 2017&#125;;// 第二个参数为一个数组，表示只保留相应的属性var jsonText = JSON.stringify(book, [\"title\", \"edition\"]);// jsonText中的字符串： &#123;\"title\":\"Story One\",\"edition\":3&#125;// 第二个参数为一个函数，通过返回指定相应属性的值，返回undefined表示删除该属性。实际上，第一次调用这个函数过滤器，传入的是一个空字符串，而值就是book对象。var jsonText = JSON.stringify(book, function (key, value) &#123; switch (key) &#123; case \"authors\": return value.join(\",\"); case \"year\": return 5000; case \"edition\": return undefined; default: return value; &#125;;&#125;);// jsonText中的字符串： &#123;\"title\":\"Story One\",\"authors\":\"Ray\",\"year\":5000&#125; &emsp;&emsp;JSON.stringify()接收最后一个（第三个）参数来表示是否在JSON字符串中保留缩进。举例如下：1234567891011121314151617181920212223242526272829303132var book = &#123; \"title\": \"Story One\", \"authors\": [ \"Ray\" ], edition: 3, year: 2017&#125;;// 第三个参数为一个数值，表示每个级别缩进的空格数var jsonText = JSON.stringify(book, null, 4);/* jsonText中的字符串：&#123; \"title\": \"Story One\", \"authors\": [ \"Ray\" ], \"edition\": 3, \"year\": 2017&#125;*/// 第三个参数为一个字符串，使用这个字符串作为缩进字符var jsonText = JSON.stringify(book, null, \" - -\");/* jsonText中的字符串：&#123; - -\"title\": \"Story One\", - -\"authors\": [ - - - -\"Ray\" - -], - -\"edition\": 3, - -\"year\": 2017&#125;*/ &emsp;&emsp;给对象定义toJSON()方法，返回指定的JSON数据格式。可以为任何对象添加toJSON()方法。举例如下：12345678910111213var book = &#123; \"title\": \"Story One\", \"authors\": [ \"Ray\" ], edition: 3, year: 2017, toJSON: function () &#123; return this.title; &#125;&#125;;var jsonText = JSON.stringify(book);// jsonText中的字符串(包括了两个双引号)： \"Story One\" &emsp;&emsp;toJSON()可以作为函数过滤器的补充，因此理解序列化的内部顺序十分重要，假设把一个对象传入JSON.stringify()，序列化该对象的顺序如下：（1）如果存在toJSON()方法而且能通过它取得有效的值，则调用该方法。否则，返回对象自身。（2）如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第（1）步返回的值。（3）对第（2）步返回的每个值进行相应的序列化。（4）如果提供了第三个参数，执行相应的格式化。 二. 解析&emsp;&emsp;JSON.parse()用于将JSON字符串解析为原生的JS值。&emsp;&emsp;JSON.parse()还可以接收另外一个参数，该参数是一个函数，称作还原函数，该还原函数返回undefined，表示要从结果中删除相应的键，如果返回其他值，则将该值插入到结果中。举例如下：12345678910111213141516171819var book = &#123; \"title\": \"Story One\", \"authors\": [ \"Ray\" ], edition: 3, year: 2015, releaseDate: new Date(2015, 3, 1)&#125;;var jsonText = JSON.stringify(book);var bookCopy = JSON.parse(jsonText, function (key, value) &#123; if (key === \"releaseDate\") &#123; return new Date(value); &#125; else &#123; return value; &#125;&#125;);// 执行 bookCopy.releaseDate.getFullYear()，得到数值2015 总结&emsp;&emsp;JSON是一种轻量级的数据格式，可以简化表示复杂数据结构的工作量。JSON使用JS语法的子集表示对象、数组、字符串、数值、布尔值和null。即使XML也能表示同样复杂的数据结果，但是JSON没有XML那么繁琐，而且在JS中使用十分便利。我们可以使用ECMAScript 5定义的原生JSON对象的两个方法stringify()以及parse()来将JS对象序列化为JSON字符串或者将JSON字符串数据解析为JS对象。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"}]}]}