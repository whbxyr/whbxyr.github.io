{"meta":{"title":"肥锐's 技术栈","subtitle":"人生虽苦短，但是什么时候学前端都不晚","description":"我不是程序员，也不是设计师，只是刚好有些想法以及一台电脑","author":"许源锐","url":"http://www.whbxyr.cn"},"pages":[{"title":"","date":"2018-06-01T15:16:53.607Z","updated":"2018-06-01T15:16:53.607Z","comments":true,"path":"baidu_verify_RUVpqOn26C.html","permalink":"http://www.whbxyr.cn/baidu_verify_RUVpqOn26C.html","excerpt":"","text":"RUVpqOn26C"},{"title":"","date":"2018-06-01T15:16:53.607Z","updated":"2018-06-01T15:16:53.607Z","comments":true,"path":"google8f959bed6376f4d8.html","permalink":"http://www.whbxyr.cn/google8f959bed6376f4d8.html","excerpt":"","text":"google-site-verification: google8f959bed6376f4d8.html"},{"title":"","date":"2018-06-01T15:16:53.607Z","updated":"2018-06-01T15:16:53.607Z","comments":true,"path":"contact/index.html","permalink":"http://www.whbxyr.cn/contact/index.html","excerpt":"","text":"我的邮箱： 网易邮箱：`raywhbxyr@163.com`"}],"posts":[{"title":"es6(二) 之用 es5 理解 es6 的 class","slug":"es6Class","date":"2019-05-13T15:43:37.000Z","updated":"2019-05-19T13:21:08.329Z","comments":true,"path":"2019/05/13/es6Class/","link":"","permalink":"http://www.whbxyr.cn/2019/05/13/es6Class/","excerpt":"","text":"&emsp;&emsp;es6 新特性 class 能够像其他面向对象的语言那样创建类并实现类之间的继承，然而实际上底层的实现依然是基于原型链的，因此完全可以将 es6 的 class 翻译成 es5 的原生 function 来理解。 声明一个类12345// class 实现class A &#123;&#125;// function 实现function A() &#123;&#125; 声明一个类并定义其原型方法 foo()12345678// class 实现class A &#123; foo() &#123;&#125;&#125;// function 实现function A() &#123;&#125;A.prototype.foo = function () &#123;&#125; 声明两个类 A 和 B，其中 B 继承于 A，包括原型上的继承以及静态属性、静态方法的继承123456789// class 实现class A &#123;&#125;class B extends A &#123;&#125;// function 实现function A &#123;&#125;function B &#123;&#125;Object.setPrototypeOf(B, A) // 等同于 B.__proto__ = AObject.setPrototypeOf(B.prototype, A.prototype) // 等同于 B.prototype.__proto__ = A.prototype","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"},{"name":"es6","slug":"es6","permalink":"http://www.whbxyr.cn/tags/es6/"}]},{"title":"最大宽高限制下的自适应比例尺寸计算","slug":"picBox","date":"2019-04-29T14:47:45.000Z","updated":"2019-05-11T15:54:09.176Z","comments":true,"path":"2019/04/29/picBox/","link":"","permalink":"http://www.whbxyr.cn/2019/04/29/picBox/","excerpt":"","text":"&emsp;&emsp;今天在做图片涂鸦的时候遇到了一个图片尺寸自适应的问题，即给一个有最大宽度跟最大高度限制的盒子，要将一张大小不确定的图片在保持宽高比的情况下完全放入盒子中，即既要图片能完全放入盒子中又要图片不变形。 &emsp;&emsp;其涉及到的主要是图片宽高的重新计算，抽象一下就是一个算法，即随意给定四个正数（x1, y1, x2, y2），求 x3 以及 y3，其需要满足的条件如下： &emsp;&emsp;（1）当 x2 &lt;= x1 &amp;&amp; y2 &lt;= y1 时，则 x3 = x2，y3 = y2。 &emsp;&emsp;（2）当 x2 &gt;= x1 || y2 &gt;= y1 时，要求 x3 以及 y3 是满足 x3 &lt;= x1 &amp;&amp; y3 &lt;= y1 &amp;&amp; (x3 / y3 === x2 / y2) 的最大值。 &emsp;&emsp;最终算法（es6 版本）如下。12345678910111213141516171819202122232425262728293031323334353637383940/** * 计算自适应图片的尺寸 * @param &#123;Number&#125; x1 最大宽度，x1 &gt; 0，必选 * @param &#123;Number&#125; y1 最大高度，y1 &gt; 0，必选 * @param &#123;Number&#125; x2 原始图片宽度，x2 &gt; 0，必选 * @param &#123;Number&#125; y2 原始图片高度，y1 &gt; 0，必选 * @return &#123;Object&#125; 自适应后的新图片尺寸 */export const picBox = (x1, y1, x2, y2) =&gt; &#123; let x3 = x2, y3 = y2 const time1 = x1 / y1 const time2 = x2 / y2 if (time1 &gt;= 1 &amp;&amp; time2 &gt;= 1 || time1 &lt;= 1 &amp;&amp; time2 &lt;= 1) &#123; if (time2 &lt; time1) &#123; if (y2 &gt; y1) &#123; x3 = (y1 * x2) / y2 y3 = y1 &#125; &#125; else &#123; if (x2 &gt; x1) &#123; y3 = (x1 * y2) / x2 x3 = x1 &#125; &#125; &#125; else if (time1 &gt;= 1 &amp;&amp; time2 &lt;= 1) &#123; if (y2 &gt; y1) &#123; x3 = (y1 * x2) / y2 y3 = y1 &#125; &#125; else if (time1 &lt;= 1 &amp;&amp; time2 &gt;= 1) &#123; if (x2 &gt; x1) &#123; y3 = (x1 * y2) / x2 x3 = x1 &#125; &#125; return &#123; width: x3, height: y3 &#125;&#125; &emsp;&emsp;现在假如图片盒子的最大宽度限制是 400，最大高度限制是 300，一张图片的尺寸是 500 * 600，那么放入盒子中的自适应图片尺寸分别是123const newSize = picBox(400, 300, 500, 600)newSize.width // 250，自适应后的宽度newSize.height // 300，自适应后的高度","categories":[{"name":"技术类-算法","slug":"技术类-算法","permalink":"http://www.whbxyr.cn/categories/技术类-算法/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"http://www.whbxyr.cn/tags/算法/"}]},{"title":"js 实现 call & apply & bind","slug":"myCallApplyBind","date":"2019-04-15T17:22:24.000Z","updated":"2019-04-16T15:37:37.454Z","comments":true,"path":"2019/04/16/myCallApplyBind/","link":"","permalink":"http://www.whbxyr.cn/2019/04/16/myCallApplyBind/","excerpt":"","text":"&emsp;&emsp;最近发现某条的前端面试很喜欢让人手写实现 bind。实际上，只要对原生 js 够熟悉的话，别说是实现 bind，连 call 还有 apply 的实现也是很简单的，本篇文章主要是记录下本人实现的代码。 (一) 手写实现 call1234567Function.prototype.myCall = function (context) &#123; let args = [...arguments].slice(1) context[this.name] = this let res = context[this.name](...args) delete context[this.name] return res&#125; (二) 手写实现 apply123456Function.prototype.myApply = function (context, args) &#123; context[this.name] = this let res = context[this.name](...args) delete context[this.name] return res&#125; (三) 手写实现 bind12345678Function.prototype.myBind = function (context) &#123; let that = this let args = [...arguments].slice(1) return function () &#123; // 调用了前面手写的 apply return that.myApply(context, args.concat([...arguments])) &#125;&#125; &emsp;&emsp;调用 bind 之后获得的绑定函数，如果将其当成构造函数和 new 搭配使用，那么原本调用 bind 时传入的第一个参数 context 将降低优先级，取而代之的是 new 操作符创建的那个新对象。而以上的实现过于简单，实现不了这个功能，以下是升级之后的版本。1234567891011121314Function.prototype.myBind = function (context) &#123; let that = this let args = [...arguments].slice(1) let fNOP = function() &#123;&#125; let fBound = function () &#123; // 调用了前面手写的 apply return that.myApply(this instanceof fBound ? this : context, args.concat([...arguments])) &#125; if (that.prototype) &#123; fNOP.prototype = that.prototype &#125; fBound.prototype = new fNOP() return fBound&#125;","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"}]},{"title":"实现 element-ui 按需加载","slug":"reduceElementUI","date":"2019-04-13T14:56:27.000Z","updated":"2019-04-13T16:21:07.927Z","comments":true,"path":"2019/04/13/reduceElementUI/","link":"","permalink":"http://www.whbxyr.cn/2019/04/13/reduceElementUI/","excerpt":"","text":"&emsp;&emsp;很多人在前端项目打包时经常会遇到打包出来的体积过大的问题，过大的资源体积会导致页面加载速度缓慢。在使用 element-ui 的时候如果单纯引入整个 element-ui 库，就会导致打包体积过大的问题。12345678910111213141516// 项目入口比如 main.js 中import Vue from 'vue'import App from './App'import router from './router'// 直接引入整个 element-ui 库import 'element-ui/lib/theme-chalk/index.css' // 样式import elementUI from 'element-ui' // vue 组件Vue.use(elementUI) // install 引入的组件new Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) &emsp;&emsp;按需加载可以大大减少打包体积。本篇文章将介绍如何实现 element-ui 的按需加载。步骤如下： (一) npm 安装 babel-plugin-component1npm install babel-plugin-component -D (二) 配置 babel1234567891011121314151617181920// babel.config.js 文件中配置 babel-plugin-componentmodule.exports = &#123; presets: [ [\"@babel/preset-env\", &#123; \"modules\": false &#125;], ], plugins: [ \"transform-vue-jsx\", \"@babel/plugin-transform-runtime\", // babel-plugin-component 配置 [ \"component\", &#123; \"libraryName\": \"element-ui\", \"styleLibraryName\": \"theme-chalk\" &#125; ] ]&#125; (三) vue 组件部分引入12345678910111213141516171819202122232425// 项目入口比如 main.js 中import Vue from 'vue'import App from './App'import router from './router'// 只引入需要的组件样式import 'element-ui/lib/theme-chalk/form.css'import 'element-ui/lib/theme-chalk/form-item.css'import 'element-ui/lib/theme-chalk/input.css'import 'element-ui/lib/theme-chalk/button.css'import 'element-ui/lib/theme-chalk/notification.css'// 只引入需要的 vue 组件import &#123; Form, FormItem, Input, Button, Notification &#125; from 'element-ui'Vue.use(Form);Vue.use(FormItem);Vue.use(Input);Vue.use(Button);Vue.prototype.$notify = Notification; // 注册快捷方式new Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;)","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"},{"name":"vue","slug":"vue","permalink":"http://www.whbxyr.cn/tags/vue/"}]},{"title":"windows 下解决 gyp ERR","slug":"gypERR","date":"2018-11-12T13:06:34.000Z","updated":"2018-11-12T15:07:23.142Z","comments":true,"path":"2018/11/12/gypERR/","link":"","permalink":"http://www.whbxyr.cn/2018/11/12/gypERR/","excerpt":"","text":"&emsp;&emsp;在 windows 上执行 npm 安装但凡涉及到 canvas，比如我最近就在使用一个 canvas 库 Fabric，就经常会报 gyp ERR。所以我的解决思路是查找安装 canvas 失败的解决方法，只要解决了 canvas 安装失败的问题，就可以解决 gyp ERR。 解决步骤&emsp;&emsp;（1）npm i -g node-gyp &emsp;&emsp;（2）npm install –global –production windows-build-tools&emsp;&emsp;注意：需要在有管理员权限的命令终端中执行。 &emsp;&emsp;（3）下载 GTK2，将下载下来的 zip 包解压到 C:\\GTK。 &emsp;&emsp;（4）这时候 npm install canvas 就可以正常安装不报 gyp ERR 了。 注意事项&emsp;&emsp;如果系统用户名是中文，还是会导致 npm 安装 canvas 报错，需要修改系统用户名为英文，方法参考文章 Win10 用户文件夹改名，修改完成后再重新按照上面的步骤安装就行。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"},{"name":"node","slug":"node","permalink":"http://www.whbxyr.cn/tags/node/"}]},{"title":"详解 JavaScript 严格模式","slug":"jsStrictMode","date":"2018-11-10T09:30:26.000Z","updated":"2018-11-10T10:10:01.823Z","comments":true,"path":"2018/11/10/jsStrictMode/","link":"","permalink":"http://www.whbxyr.cn/2018/11/10/jsStrictMode/","excerpt":"","text":"&emsp;&emsp;ECMAScript 5 定义了严格模式，可以使 JavaScript 更清晰，减少不安全的功能，并提供更多的警告和有逻辑的行为。同时也是为了提高编译器效率，增加运行速度，为未来新版本的 Javascript 做好铺垫。 (一) 切换到严格模式的方法：&emsp;&emsp;（1）在 JavaScript 文件顶部或者 script 元素的顶部键入 ‘use strict’。&emsp;&emsp;注意：不支持 ECMAScript 5 严格模式的 JavaScript 引擎将自动忽略 ‘use strict’，不产生任何效果。可以做到前一个 script 是严格模式而后一个不是，如下： &emsp;&emsp;（2）在函数 function 顶部键入 ‘use strict’。 &emsp;&emsp;（3）ECMAScript 2015 引入了 JavaScript 模块，这种模块内的全部内容自动处于严格模式，无需语句 ‘use strict’ 即可启动它。 (二) 使用严格模式的注意事项：&emsp;&emsp;（1）历史代码可能依赖于不再可用的功能或者依赖于在草率模式下生效的功能，在这种代码中草率切换到严格模式可能会导致代码无法执行。但是你可以将新建的严格模式函数放到草率模式的文件中，避免产生冲突。 &emsp;&emsp;（2）打包代码、压缩代码的时候，如果混合了严格模式跟草率模式的代码，可能会破坏代码。 (三)严格模式相比草率模式有什么不同：&emsp;&emsp;（1）所有变量都必须有相应的声明，不能对未声明的变量执行任何操作。&emsp;&emsp;注意：草率模式下，给未声明的变量赋值就是给全局变量赋值。 &emsp;&emsp;（2）不能给属于基本数据类型的表达式或原始值设置属性。&emsp;&emsp;例子：false.true = ‘’; (14).sailing = ‘home’; ‘with’.you = ‘far away’; 这些都会报错 TypeError。&emsp;&emsp;注意：草率模式下静默失败，无任何作用。 &emsp;&emsp;（3）函数必须声明在作用域顶级（全局作用域或者函数的顶级作用域）。&emsp;&emsp;注意：草率模式下，函数可以在任何地方声明；严格模式下，若想在块级作用域内声明函数，只能通过将匿名函数赋值给变量的方法。 &emsp;&emsp;（4）函数接收的参数名不能重复，对象不能含有重复的属性。&emsp;&emsp;注意：草率模式下，对于函数，重复的参数值依然可以在 arguments 对象中访问到，但是实际的参数值会被后一个重复的参数值覆盖，对于对象，最后一个重复属性的值会覆盖前面的重复属性的值。 &emsp;&emsp;（5）不能给 arguments 重新赋值，arguments 对象的 caller 属性和 callee 属性均被废除，且 arguments 内参数值的变化不再跟具体的函数参数变化有关联，即改变 arguments[0] 的值不会影响第一个函数参数的值，改变了第一个函数参数的值也不会导致 arguments[0] 的值发生改变。&emsp;&emsp;注意：草率模式下，arguments 记录的参数值跟实际的参数值是互相追踪关联的。 &emsp;&emsp;（6）不能给 eval 重新赋值，eval 执行时拥有自己的内部作用域，这是除了全局作用域、函数作用域、块级作用域外的第四种作用域，例如执行 var x = 2; eval(‘var x = 5;’); 时，第一个 x 的值将依然是 2。 &emsp;&emsp;（7）不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈，使用了会报错。 &emsp;&emsp;（8）在函数中，未对 this 赋值的话 this 就是 undefined。&emsp;&emsp;注意：严格模式下如果你忘了使用 new 来调用构造函数，就会报不能对 undefined 赋值的错。 &emsp;&emsp;（9）不能设置和删除不可变属性，不能对 undefined 、NaN 等不可写变量赋值，不能对只有 getter 却没有 setter 的属性赋值，不能扩展不可扩展的对象的属性。&emsp;&emsp;注意：草率模式下只会静默失败。 &emsp;&emsp;（10）不能删除变量，只有 configurable 设置为 true 的对象属性，才能被删除。&emsp;&emsp;注意：var x = 12; delete x; 会报错，草率模式下只会静默失败。 &emsp;&emsp;（11）with 语句被废弃了，再也不能使用 with 为对象绑定属性。 &emsp;&emsp;（12）不能使用前缀 0 表示八进制数，否则报错。在 ECMAScript 2015 中要使用 0o 作为前缀表示八进制数。 &emsp;&emsp;（13）严格模式增加了保留字（比如 protected、implements、interface、private、static 等等）。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"}]},{"title":"JavaScript 中 new 操作符的执行顺序","slug":"new","date":"2018-11-04T04:24:18.000Z","updated":"2018-11-04T07:21:13.628Z","comments":true,"path":"2018/11/04/new/","link":"","permalink":"http://www.whbxyr.cn/2018/11/04/new/","excerpt":"","text":"&emsp;&emsp;以前在学习 JavaScript 构造函数的时候，并没有深入地去研究 new 操作符究竟做了什么事情，也没有深入了解构造返回值的规则，本篇文章详细解释了这两个问题。 new 操作符做了什么？？？&emsp;&emsp;用 new 调用构造函数时 new 的操作顺序： （一）创建一个新对象 X； （二）将新对象 X 的属性 proto 指向构造函数的 prototype 指向的地方； （三）将构造函数中的 this 绑定为新对象 X； （四）执行构造函数中的代码，比如 this.a = ‘xx’ 等等； （五）判断构造函数中是否有 return 语句，没有的话就返回新对象 X，有的话先判断 return 后面的值是否为引用类型，是引用类型的话就返回该值，否则依然返回新对象 X。 注意&emsp;&emsp;（一）对于构造函数，如果没有通过 new 去调用，那么实际该函数返回什么由函数中 return 的具体值决定，即有 return 语句的话 return 什么就返回什么，没有 return 语句的话就返回 undefined； &emsp;&emsp;（二）但是如果用 new 去调用构造函数，如果没有 return 语句，那就返回由 new 创建的那个对象，有 return 语句的话，先判断 return 后面的是不是引用类型的指，如果是引用类型的值，就返回该值，否则依然返回由 new 创建的那个对象。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"}]},{"title":"多 PC 终端调试利器之 Mouse without Borders","slug":"mouseWithoutBorders","date":"2018-10-24T10:10:09.000Z","updated":"2018-10-26T17:11:36.476Z","comments":true,"path":"2018/10/24/mouseWithoutBorders/","link":"","permalink":"http://www.whbxyr.cn/2018/10/24/mouseWithoutBorders/","excerpt":"","text":"&emsp;&emsp;对于某些特定场景，比如音视频通话，开发调试的时候需要由两台 PC 之间进行交互。这种场景调试起来是十分费劲的，一方面文件没办法共享，另一方面操作界面是分开的，鼠标做不到共享，你不得不在两个鼠标之间来回切换。而本文介绍的利器 Mouse without Borders 就可以完美地解决这个问题。 下载安装&emsp;&emsp;下载安装包请戳 Mouse without Borders，下载完成后在你需要调试的两台 PC 上都安装上这个软件。 配置&emsp;&emsp;注意：在配置之前请一定确保你的两台 PC 机处于同一个网段（局域网）下，比如都连接上了同一个 wifi。 &emsp;&emsp;两台 PC 机一台充当 server 端，提供服务主机名和密码，另一台充当 client 端，用来连接 server 端（需要服务主机名和密码）。 &emsp;&emsp;client 端连接 server 端也很简单，按照以下图示步骤即可，核心是将前面的服务主机名以及密码填入即可。 第一步 第二步 第三步 第四步&emsp;&emsp;这里填入的服务主机名以及密码便是 server 端提供的。 第五步 第六步&emsp;&emsp;现在你就可以尽情地玩耍了，不仅可以用一个鼠标在两个 PC 之间进行无缝操作，还可以将文件从一台 PC 拖动（复制黏贴）到另一台 PC 上。","categories":[{"name":"技术类-奇淫巧技","slug":"技术类-奇淫巧技","permalink":"http://www.whbxyr.cn/categories/技术类-奇淫巧技/"}],"tags":[{"name":"奇淫巧技","slug":"奇淫巧技","permalink":"http://www.whbxyr.cn/tags/奇淫巧技/"}]},{"title":"全双工通信 & WebSocket","slug":"ws","date":"2018-10-23T06:19:41.000Z","updated":"2018-10-25T00:44:27.689Z","comments":true,"path":"2018/10/23/ws/","link":"","permalink":"http://www.whbxyr.cn/2018/10/23/ws/","excerpt":"","text":"&emsp;&emsp;随着互联网的迅速发展，单工以及半双工的通信方式已经无法满足日益复杂的业务需求了，对全双工通信的依赖越来越重。而 WebSocket 协议便是全双工通信协议中的一个典型代表。 单工、半双工、全双工&emsp;&emsp;数据通信中，数据在线路上的传送方式可以分为单工通信、半双工通信和全双工通信三种。 单工&emsp;&emsp;所谓单工通信，是指消息只能单方向传输的工作方式。它的信道是单向信道，发送端跟接收端都是固定的，数据只能从发送端向接收端流动。例如遥控、遥测，就是单工通信方式。 半双工&emsp;&emsp;以半双工数通信方式工作的数据传输，数据可以在一个信号载体的两个方向上传输，但是不能同时传输。比如 http 协议就是基于半双工的方式工作的。 全双工&emsp;&emsp;全双工通信允许数据同时在两个方向上进行传输，也就是说任一一端在同一时间内既可以是数据接收端也可以是数据发送端。 全双工通信（服务器推送）的模拟&emsp;&emsp;在全双工通信未成熟的年代主要通过短轮询、长轮询以及流这三种方式来模拟。 （一）短轮询&emsp;&emsp;客户端通过 Ajax 的方式，每隔一小段时间就发送一个请求到服务器，服务器返回最新数据。 &emsp;&emsp;优点：逻辑简单，实现起来容易&emsp;&emsp;缺点：服务器压力较大，浪费带宽流量（通常数据并没有立马发生变化） （二）长轮询&emsp;&emsp;客户端发送一个请求到服务器，服务器查看需要的数据是否发生了变化，如果有变化就立即响应返回数据，否则保持这个连接并定期检查最新数据直到发生了数据更新或者连接超时。 &emsp;&emsp;优点：逻辑简单，实现起来容易&emsp;&emsp;缺点：服务器压力较大，浪费带宽流量（通常数据并没有立马发生变化） （三）流&emsp;&emsp;浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据。&emsp;&emsp;优点：只发送一次请求，然后服务端保持与客户端的长连接&emsp;&emsp;缺点：依赖于 XHR 对象的 readyState 属性，部分浏览器（IE）不支持，需要使用不同的技术进行兼容 WebSocket 介绍诞生背景&emsp;&emsp;随着 web 的发展，需要使用到全双工通信的场景越来越多，使用全双工通信的需求也越来越大。前面介绍的模拟实现的方式，其实都是利用浏览器单向请求服务器或者服务器单向推送数据到浏览器这些技术来做 hack 的，为了避免 hack 的不便性以及加强 web 的功能，全双工通信协议 WebSocket 诞生了。 兼容性&emsp;&emsp;目前流行的浏览器对 WebSocket 的支持都是很友好的。生产环境使用 WebSocket 是很常见的。 浏览器端的实现&emsp;&emsp;详细可参考 MDN 文档 WebSocket。 服务端的实现&emsp;&emsp;很多服务端框架实现了对 WebSocket 的支持，常用的 Node 实现有以下三种。 µWebSockets Socket.IO WebSocket-Node &emsp;&emsp;本人使用 WebSocket-Node 实现了一个简易类 IM 系统。移步 GitHub。 WebSocket 使用场景 即时通讯 IM：包括社交聊天、弹幕等等 服务端推送：天气预报实时更新、股票基金实时报价等等 信道服务：在线教育、在线直播等场景下依赖的信道 总结&emsp;&emsp;WebSocket 是基于 TCP 长连接的网络协议，它与 http 一样属于应用层协议，但是它与其他应用层协议的不同点在于它在建立连接后，通信双方都可以在任何时刻向另一方发送数据。","categories":[{"name":"技术类-网络协议","slug":"技术类-网络协议","permalink":"http://www.whbxyr.cn/categories/技术类-网络协议/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"},{"name":"网络协议","slug":"网络协议","permalink":"http://www.whbxyr.cn/tags/网络协议/"}]},{"title":"vue 脚手架之 vue-cli 的使用","slug":"vue-cli","date":"2018-10-20T14:58:29.000Z","updated":"2018-10-21T03:39:20.456Z","comments":true,"path":"2018/10/20/vue-cli/","link":"","permalink":"http://www.whbxyr.cn/2018/10/20/vue-cli/","excerpt":"","text":"&emsp;&emsp;vue 的发展是很快的，围绕 vue 已经有了一个完整的应用生态，比如 vue + vuex + vue-router + axios + webpack 就是一个完整的应用系统了。那么，每次我们要新建一个运用了此应用系统的项目的时候，都要重新搭建项目吗？回答是肯定的，也确实很麻烦，但是 vue-cli 作为一个 vue 的专门脚手架，可以轻松帮我们解决这样的问题。 &emsp;&emsp;vue-cli 目前版本已经到 3.0 了。3.0 版本跟之前的 2.0 、1.0 这两个版本的使用方式已经不太一样了。为了跟上脚手架的发展，本篇文章着重介绍 3.0 版本的使用。 安装及使用12345678910// 假如你之前安装过 3.0 以前的版本，需要先执行以下命令，否则忽略npm uninstall vue-cli -g// 全局安装最新的 vue-clinpm install -g @vue/cli// 创建项目vue create hello-world// 开启服务npm run serve// 项目打包npm run build &emsp;&emsp;以上介绍的都只是最基本的使用，由于文章篇幅限制，就不在这里展开详细的使用介绍，详见文档 Vue CLI 3 在 3.0 版本下使用 2.0 版本的命令&emsp;&emsp;Vue CLI 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具：1234npm install -g @vue/cli-init// vue init 的运行效果将会跟 vue-cli@2.x 相同vue init webpack my-projectvue-cli@2.x webpack my-project &emsp;&emsp;vue init 创建出来的项目模板是基于 webpack 3 及以下版本的，如果你想使用最新的 webpack 4 版本，可以使用以下命令创建项目：1vue init noamkfir/webpack#webpack-4 project 注意：winpty 命令的使用&emsp;&emsp;如果你在 Windows 上通过 minTTY 使用 Git Bash，交互提示符并不工作。你必须通过 winpty vue.cmd create hello-world 启动这个命令。另外，有些命令在 git bash 里面执行后会乱码，在命令前面加上 winpty 也可以解决乱码问题。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"},{"name":"脚手架","slug":"脚手架","permalink":"http://www.whbxyr.cn/tags/脚手架/"}]},{"title":"window.location 对象详解","slug":"location","date":"2017-08-27T04:17:16.000Z","updated":"2018-06-01T15:16:53.575Z","comments":true,"path":"2017/08/27/location/","link":"","permalink":"http://www.whbxyr.cn/2017/08/27/location/","excerpt":"","text":"window.location 的属性&emsp;&emsp;本文通过一个示例 url，讲述window.location的各个属性。假设该url如下：1https://www.baidu.com/s?wd=location.hash&amp;rsv_spt=1&amp;rsv_iqid=0xa78ca3100003b820&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_t=6decUG6FR%2BbaSb%2FPMsTCZmiKd2aU05OANFzmoTyRD5hNNitxtu1jTmnpxMiD1NK6nql%2F&amp;oq=location.hash&amp;inputT=6&amp;rsv_sug3=9&amp;rsv_sug1=8&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_pq=a80d243900049765&amp;rsv_sug4=190534#imhere &emsp;&emsp;当我们访问这个网页的时候，在控制台运行以下代码：12345678910111213141516// 控制台中输入以下代码：JSON.stringify(window.location);/* 可以获得以下字符串（为方便查看，手动缩进规范处理了下）\"&#123; \"href\":\"https://www.baidu.com/s?wd=location.hash&amp;rsv_spt=1&amp;rsv_iqid=0xa78ca3100003b820&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_t=6decUG6FR%2BbaSb%2FPMsTCZmiKd2aU05OANFzmoTyRD5hNNitxtu1jTmnpxMiD1NK6nql%2F&amp;oq=location.hash&amp;inputT=6&amp;rsv_sug3=9&amp;rsv_sug1=8&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_pq=a80d243900049765&amp;rsv_sug4=190534#imhere\", \"ancestorOrigins\":&#123;&#125;, \"origin\":\"https://www.baidu.com\", \"protocol\":\"https:\", \"host\":\"www.baidu.com\", \"hostname\":\"www.baidu.com\", \"port\":\"\", \"pathname\":\"/s\", \"search\":\"?wd=location.hash&amp;rsv_spt=1&amp;rsv_iqid=0xa78ca3100003b820&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_t=6decUG6FR%2BbaSb%2FPMsTCZmiKd2aU05OANFzmoTyRD5hNNitxtu1jTmnpxMiD1NK6nql%2F&amp;oq=location.hash&amp;inputT=6&amp;rsv_sug3=9&amp;rsv_sug1=8&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_pq=a80d243900049765&amp;rsv_sug4=190534\", \"hash\":\"#imhere\"&#125;\"*/ &emsp;&emsp;由上可得 window.location 的10个属性：&emsp;&emsp;href / ancestorOrigins / origin / protocol / host&emsp;&emsp;hostname / port / pathname / search / hash window.location.href整个URl字符串(在浏览器中就是完整的地址栏)本例返回值: https://www.baidu.com/s?wd=location.hash&amp;rsv_spt=1&amp;rsv_iqid=0xa78ca3100003b820&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_t=6decUG6FR%2BbaSb%2FPMsTCZmiKd2aU05OANFzmoTyRD5hNNitxtu1jTmnpxMiD1NK6nql%2F&amp;oq=location.hash&amp;inputT=6&amp;rsv_sug3=9&amp;rsv_sug1=8&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_pq=a80d243900049765&amp;rsv_sug4=190534 window.location.protocolURL 的协议部分本例返回值: https: window.location.hostURL 的主机部分本例返回值: www.baidu.com window.location.hostnameURL 的主机部分，在这里 window.location.hostname === window.location.host本例返回值: www.baidu.com window.location.portURL 的端口部分如果采用默认的80端口(即使添加了:80)，那么返回值并不是默认的80而是空字符本例返回值: “” window.location.pathnameURL 的路径部分(就是文件地址)本例返回值: /s window.location.search查询(参数)部分除了给动态语言赋值以外，我们同样可以给静态页面,并使用javascript来获得相信应的参数值本例返回值: ?wd=location.hash&amp;rsv_spt=1&amp;rsv_iqid=0xa78ca3100003b820&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_t=6decUG6FR%2BbaSb%2FPMsTCZmiKd2aU05OANFzmoTyRD5hNNitxtu1jTmnpxMiD1NK6nql%2F&amp;oq=location.hash&amp;inputT=6&amp;rsv_sug3=9&amp;rsv_sug1=8&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_pq=a80d243900049765&amp;rsv_sug4=190534 window.location.hash锚点本例返回值: #imhere window.location 改变当前页面 url 的方法 window.location = ‘xxx’; location = ‘xxx’; window.location.href = ‘xxx’; location.href = ‘xxx’; window.replace(‘xxx’); &emsp;&emsp;这五种方法都会让浏览器的历史记录里面多一项，但是有一个较大的区别就是前四种方法依然可以通过使用浏览器的“前进”和“后退”按钮回到替换url之前的原始url，但是对于最后一种方法 window.replace(url)，则将失去浏览器的“前进”和“后退”按钮功能，因为该方法通过指定URL替换当前缓存在历史里（客户端）的项目，因此当使用replace方法之后，你不能通过“前进”和“后退”来访问已经被替换的URL。 window.location.reload([bForceGet])&emsp;&emsp;window.location.reload([bForceGet])方法接收一个参数，默认为false，即刷新当前页面并如果有缓存的话就从缓存里面读取页面。当传入这个方法的参数为true时，则表示强刷页面，效果与用户直接 Ctrl + F5 的效果是一样的，即直接从服务器获取最新的页面。 使用 window.location.hash 欺骗浏览器&emsp;&emsp;有这么一个场景，就是在一个页面里面，浏览到了你想收藏的地方，这时候你收藏了链接，下次再打开的时候，却发现还是要从头开始找那个你想收藏的地方。但是，使用 window.location.hash 可以解决这个问题。&emsp;&emsp;解决方法就是给链接加上一个hash值，每次打开链接的时候使用js去获取这个hash值，并根据不同的hash值显示不同的页面。这样，还可以欺骗浏览器，让浏览器以为加了hash的链接是一个新的页面，这样就可以充分使用浏览器的“前进”和“后退”功能了。123456789101112131415161718// 示意代码window.onload = function () &#123; var hash = window.location.hash; switch (hash) &#123; case &apos;part1&apos;: showPart1(); break; case &apos;part2&apos;: showPart2(); break; case &apos;&apos;: showPart0(); break; default: showPart0(); break; &#125;&#125;; 注意window.location === document.location 在没有使用 iframe 时，结果为 true，即两者没有什么区别，但是一旦页面中使用了 iframe 框架，就会有不同了，在 iframe 中的 window.location 等同于 top.location，但是不一定与 document.location 等同。 总结&emsp;&emsp;合理利用window.location可以实现很多有趣的功能，比如在 a 标签中使用 href=”#” 可以实现快速回到页面顶部。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"}]},{"title":"理解语义化","slug":"semantic","date":"2017-07-22T11:17:16.000Z","updated":"2018-06-01T15:16:53.591Z","comments":true,"path":"2017/07/22/semantic/","link":"","permalink":"http://www.whbxyr.cn/2017/07/22/semantic/","excerpt":"","text":"&emsp;&emsp;以前开始学前端、作为一名萌新的时候，一上来就是狂刷 html 的各种标签，拿到 &lt;div&gt; &lt;span&gt; 就是学习如何实现各种炫酷效果，很多实现都基本会首选这两个标签，但是却基本不考虑语义化这种看似“很玄”的东西，但是随着自己接触的项目逐渐增多以及现 HTML 5 的流行，慢慢发现如果有更高追求的话，语义化就是一个不得不考虑的点。 语义化的定义&emsp;&emsp;上维基百科搜了一下，它对语义化的定义如下： 语义化是前端开发里面的一个专用术语，其优点在于标签语义化有助于构架良好的html结构，有利于搜索引擎的建立索引、抓取；另外，亦有利于页面在不同的设备上显示尽可能相同；此外，亦有利于构建清晰的机构，有利于团队的开发、维护。 &emsp;&emsp;这段维基百科是2012年编写的，可见语义化并不是一个新概念，在搜索引擎大行其道的web2.0时代，甚至是在更早的时候，大家就都已经意识到了语义化这个概念了，语义化并不是 HTML 5 专有的概念。&emsp;&emsp;在我看来，语义化的 html 就是让相应的标签做相应的事情，在没有 CSS 样式的情况下，网页也以正确的文档格式显示。这样不仅便于开发者阅读理解代码以及写出更优雅的代码，还能页面内容结构化，让网络爬虫很好地解析网页，实现 SEO 优化。 总结语义化的作用 在没有 CSS 样式的时候能够清楚体现页面的结构，增强可读性 语义化的 html 让开发者更容易看明白，便于团队的开发和维护，提高团队的开发效率 有利于网页在多个终端的浏览器内正常渲染、显示 有利于网页的 SEO 优化，结构语义化的 html 能够被搜素引擎更好地理解和爬取 怎么写语义化的 html&emsp;&emsp;实现语义化的 html，关键就是要实现结构与样式分离。站在 html 的角度上，它只告诉我们它包含的内容是什么，意义是什么，但是它的样式不应该由自己来决定，而应该由 CSS 来决定。&emsp;&emsp;总的来说，写语义化 的 html 其实并不苦难。主要包含以下几点： 掌握 html 中各个标签的语义，比如&lt;h1&gt;~&lt;h6&gt;表示标题，&lt;p&gt;表示段落，&lt;header&gt;、&lt;main&gt;、&lt;footer&gt;分别表示页面的头部、主体以及页脚等等。 在构建 html 的时候，提前想好某块内容的结构语义，判断它是一个标题还是段落或者一篇文章等等。 在实际敲 html 代码的时候，根据具体语义选择对应的标签就可以了。 有哪些语义化的标签&emsp;&emsp;举一些 HTML 5 的新的语义化标签： &lt;header&gt; &lt;footer&gt; &lt;hgroup&gt; &lt;nav&gt; &lt;aside&gt; &lt;section&gt; &lt;article&gt; …… &emsp;&emsp;下面图片展示的是一个语义化 html 的例子。 参考资料HTML 5的革新——语义化标签(一)什么是语义化的HTML?有何意义？为什么要做到语义化？","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"html","slug":"html","permalink":"http://www.whbxyr.cn/tags/html/"}]},{"title":"动态加载js脚本并判断是否加载完成","slug":"judgeAsyncJs","date":"2017-07-17T11:17:16.000Z","updated":"2018-06-01T15:16:53.575Z","comments":true,"path":"2017/07/17/judgeAsyncJs/","link":"","permalink":"http://www.whbxyr.cn/2017/07/17/judgeAsyncJs/","excerpt":"","text":"&emsp;&emsp;异步加载js的方法可以是先创建一个&lt;script&gt;标签，再给这个标签添加src属性并将该元素添加到文档后，这时候浏览器就会开始异步加载JavaScript文件。它与图像不同的是，为图像创建的&lt;img&gt;标签，一旦给予了它src属性，它就会立马加载图片，而不管&lt;img&gt;标签是否已经被插入文档中。 &emsp;&emsp;因此，对于&lt;script&gt;元素而言，指定src属性和指定事件处理程序的先后顺序就不重要了，在这一点上，与&lt;link&gt;标签的表现是一致的，&lt;link&gt;标签在href属性被赋值后也不会立即下载样式表，只有将该元素添加到文档中后才会开始下载，因此指定href属性和指定事件处理程序的先后顺序也不重要了；而对于&lt;img&gt;元素而言，则必须先指定事件处理程序，再赋予src属性，否则会出现捕获不到加载完成事件的情况。 动态加载js文件并判断状态（一）监听 load 事件&emsp;&emsp;其中使用了跨浏览器的 EventUtil 对象，详见我的文章 兼容浏览器的事件处理程序 EventUtil！12345678910111213// 待文档及资源加载完毕后，再异步动态加载一个js文件EventUtil.addHandler(window, 'load', function () &#123; // 创建一个&lt;script&gt;标签 var script = document.createElement('script'); // 添加 load 事件的监听 EventUtil.addHandler(script, 'load', function () &#123; console.log('异步脚本加载完毕'); &#125;); // 赋予 src 属性 script.src = 'example.js'; // 将&lt;script&gt;标签插入到文档中后开始加载js文件 document.body.appendChild(script);&#125;); &emsp;&emsp;以上便是异步加载js文件并判断是否加载完成的方法之一。 （二）监听对象的 readyState 属性&emsp;&emsp;其中依然使用了跨浏览器的 EventUtil 对象。1234567891011121314151617181920212223// 待文档及资源加载完毕后，再异步动态加载一个js文件EventUtil.addHandler(window, 'load', function () &#123; // 创建一个&lt;script&gt;标签 var script = document.createElement('script'); // 添加 readystatechange 事件的监听 EventUtil.addHandler(script, 'readystatechange', function (event) &#123; // 获取事件 event = EventUtil.getEvent(event); // 获取发生相应事件的 DOM 对象 var target = EventUtil.getTarget(event); // 根据对象的 readyState 属性的值来判断加载是否完成 if (target.readyState === 'loaded' || target.readyState === 'complete') &#123; EventUtil.removeHandler(target, 'readystatechange', arguments.callee); console.log('异步脚本加载完毕'); &#125; &#125;); // 赋予 src 属性 script.src = 'example.js'; // 将&lt;script&gt;标签插入到文档中后开始加载js文件 document.body.appendChild(script);&#125;); &emsp;&emsp;这种方法主要是依据 readystatechange 事件来判断动态加载的js文件是否加载完成。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"}]},{"title":"调研 flv.js","slug":"flvjs","date":"2017-07-17T07:17:16.000Z","updated":"2018-06-01T15:16:53.560Z","comments":true,"path":"2017/07/17/flvjs/","link":"","permalink":"http://www.whbxyr.cn/2017/07/17/flvjs/","excerpt":"","text":"前言&emsp;&emsp;目前常见的直播协议及其简单介绍如下： RTMP: 底层基于TCP，在浏览器端依赖Flash。 HTTP-FLV: 基于HTTP流式IO传输FLV，依赖浏览器支持播放FLV。 WebSocket-FLV: 基于WebSocket传输FLV，依赖浏览器支持播放FLV。WebSocket建立在HTTP之上，建立WebSocket连接前还要先建立HTTP连接。 HLS: Http Live Streaming，苹果提出基于HTTP的流媒体传输协议。HTML5可以直接打开播放。 RTP: 基于UDP，延迟1秒，浏览器不支持。 &emsp;&emsp;常见直播协议延迟与性能数据（只做对比参考）如下： 传输协议 播放器 延迟 内存 CPU RTMP Flash 1s 430M 11% HTTP-FLV Video 1s 310M 4.4% HLS Video 20s 205M 3% 在支持浏览器的协议里，延迟排序是：&emsp;&emsp;RTMP = HTTP-FLV = WebSocket-FLV &lt; HLS而性能排序则恰好相反：&emsp;&emsp;RTMP &gt; HTTP-FLV = WebSocket-FLV &gt; HLS从这点上看的话， 延迟小的性能反而不好。 另外，通过以上比较，综合延迟以及性能，可见在浏览器上做直播的话，使用 HTTP-FLV 协议是不错的。 什么是flv.js？&emsp;&emsp;flv.js是一个不借助于Flash却可以实现在浏览器上播放HTML5 Flash流媒体视频(FLV)的，由纯原生的JavaScript编写的js插件。&emsp;&emsp;基本原理是通过将 FLV 文件流转码复用成 ISO BMFF（MP4 碎片）片段，然后通过 Media Source Extensions（API） 将 MP4 片段喂进浏览器。它是前bilibili的员工受到hls.js的启发而创作的一个开源项目，github入口请点击这里！ &emsp;&emsp;本文将顺序介绍flv.js的功能、优点、缺点，并在最后给出一个使用flv.js的实例。 flv.js的功能&emsp;&emsp;目前各大浏览器厂商已经默认禁用 Flash，以前常见的Flash直播方案需要用户同意使用Flash后才可以正常使用直播功能，这样的用户体验很致命。&emsp;&emsp;而flv.js则可以在不使用 Flash 的情况下播放FLV流视频。下面列出了它的几点功能： 它是一个具有H.264 + AAC编码器播放功能的FLV 容器 多部分分段视频播放 HTTP FLV 低延迟实时流播放 FLV 通过 WebSocket 实时流播放 兼容 Chrome, FireFox, Safari 10, IE11 和 Edge 开销很低，使用了浏览器的硬件加速 flv.js的优点 HTML5 原生仅支持播放 mp4/webm 格式，flv.js 实现了在HTML5上播放FLV格式视频 建立在采用了硬件加速的Video标签上，因此性能好，支持高清 在 HTML5 上支持了延迟极低的 HTTP FLV 播放，解决了对Flash的依赖问题 支持录播和直播 flv.js的缺点 FLV里所包含的视频编码必须是H.264，音频编码必须是AAC或MP3， IE11和Edge浏览器不支持MP3音频编码，所以FLV里采用的编码最好是H.264+AAC。 在录播上依赖于原生 HTML5 的Video标签和Media Source Extensions API。 在直播上不仅依赖于原生 HTML5 的Video标签和Media Source Extensions API，同时依赖 HTTP-FLV 或者 WebSocket 中的一种协议来传输FLV。其中 HTTP FLV 需通过流式IO去拉取数据，比如fetch或者stream。 flv.min.js 文件gzip压缩后与flash播放器gzip压缩后的大小相差无几。 由于依赖Media Source Extensions API，目前所有iOS和Android4.4.4以下里的浏览器都不支持，也就是说目前对于移动端flv.js基本是不能用的。 使用实例&emsp;&emsp;使用flv.js的一个具体例子可以点击 这里 !&emsp;&emsp;在 Google Chrome 59.0.3071.115 (正式版本) （32 位）中的效果图如下： &emsp;&emsp;而在 Android 6.0.1 的小米4手机的浏览器上是无法使用的。如下图： &emsp;&emsp;另外，其在 iOS 上的 Safari 浏览器下也是无法使用的。 综上，flv.js在移动端上的使用还是比较局限的。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"},{"name":"插件","slug":"插件","permalink":"http://www.whbxyr.cn/tags/插件/"}]},{"title":"使用 js 实现栈并解决正整数\"进制转换\"的问题","slug":"jsStack","date":"2017-07-09T16:18:27.000Z","updated":"2018-06-01T15:16:53.575Z","comments":true,"path":"2017/07/10/jsStack/","link":"","permalink":"http://www.whbxyr.cn/2017/07/10/jsStack/","excerpt":"","text":"&emsp;&emsp;在这篇文章中，我将结合 js 的构造函数以及 js 的数组，实现数据结构栈并利用 js 实现的栈来实现正整数的 进制转换算法，即将正整数转换为其他进制的数（包括二进制到十六进制）。 (一) 利用 js 实现数据结构栈&emsp;&emsp;充分利用 ECMAScript 原生的构造函数以及原生的数据结构数组，可以很容易地实现栈。代码以及注释如下：1234567891011121314151617181920212223242526272829303132function Stack() &#123; // 初始化栈 var items = []; // 入栈 this.push = function (item) &#123; items.push(item); &#125;; // 出栈 this.pop = function () &#123; return items.pop(); &#125;; // 获取栈顶元素 this.peek = function () &#123; return items[items.length - 1]; &#125;; // 判空 this.isEmpty = function () &#123; return items.length === 0; &#125;; // 获取栈的大小 this.size = function () &#123; return items.length; &#125;; // 清空栈 this.clear = function () &#123; items = []; &#125;; // 打印栈 this.print = function () &#123; console.log(items.toString()); &#125;;&#125; (二) 利用栈将正整数转换为其他进制数（2~16）&emsp;&emsp;只要知道十进制数转换为其他进制数的原理，就可以很简单地利用栈来实现。原理就是通过不断地进行除法，将余数放入栈中，等到原来的十进制数变为零时，再将栈中的数据逐个出站拼接，便能获得我们想要的目标进制数。代码以及注释如下所示：12345678910111213141516171819202122232425262728/* * 十进制正整数： decNumber * 目标进制(base &gt;= 2 &amp;&amp; base &lt;= 16)： base */function baseConvert(decNumber, base) &#123; // 初始化余数栈 var remStack = new Stack(); // 初始化余数 var rem; // 初始化转换结果 var baseString = ''; // 解决11到16进制之间的进制数表示问题 var digits = '0123456789ABCDEF'; // 计算余数栈 while (decNumber &gt; 0) &#123; rem = decNumber % base; remStack.push(rem); decNumber = Math.floor(decNumber / base); &#125; // 计算结果 while (!remStack.isEmpty()) &#123; baseString += digits[remStack.pop()]; &#125; return baseString;&#125; &emsp;&emsp;另外，只要知道如何将十进制正整数转换为其他进制的数，那么也可以轻松实现任何进制之间的转换。在我看来，分为两个步骤：&emsp;&emsp;1. 将原始进制数a转换为十进制数b&emsp;&emsp;2. 将得到的b再利用上述算法，即可得到最终的目标进制数c","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"http://www.whbxyr.cn/tags/算法/"}]},{"title":"path.join 与 path.resolve 的区别","slug":"path-join-path-resolve","date":"2017-05-31T13:07:48.000Z","updated":"2018-06-01T15:16:53.575Z","comments":true,"path":"2017/05/31/path-join-path-resolve/","link":"","permalink":"http://www.whbxyr.cn/2017/05/31/path-join-path-resolve/","excerpt":"","text":"何为 path ？&emsp;&emsp;path是node提供的用于处理文件路径的小工具，我们可以通过以下方式引入该模块：1var path = require('path'); &emsp;&emsp;path.join以及path.resolve便是该模块中的两个方法。官方对这两个方法的定义分别如下： path.join([path1][, path2][, …]) path.resolve([from …], to) 用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是”/“，Windows系统是”\\”。 将 to 参数解析为绝对路径。 &emsp;&emsp;很多同学在使用中分不清楚它们两者之间的区别。接下来，我们就来看看它们二者之间的区别。 path.join 与 path.resolve 的区别 相同点 1.二者都是输出路径字符串 2.二者都能正确处理父级标识&#39;../&#39;例子：现假设在 ububtu 的 home 目录的 test 文件夹里新建一个 path.js 文件。（以下均以这个文件作为例子讲解）123456789101112/** * path.js */var path = require('path');// 使用 path.joinconsole.log(path.join(__dirname, '../hexo'));// 输出 /home/whbxyr/hexo// 使用 path.resolveconsole.log(path.resolve(__dirname, '../hexo'));// 输出 /home/whbxyr/hexo &emsp;&emsp;可见二者均是将&#39;../&#39;视为父级目录，而不是当成简单的字符串。 不同点 1.path.join 只是简单的连接路径，而 path.resolve 则是将最后一个参数的路径解析为绝对路径。123456789101112/** * path.js */var path = require('path');// 使用 path.joinconsole.log(path.join('test', './hexo'));// 输出 test/hexo// 使用 path.resolveconsole.log(path.resolve('test', './hexo'));// 输出 /home/whbxyr/test/test/hexo 2.path.join 将&#39;/&#39;视为简单的当前路径，而 path.resolve 将&#39;/&#39;视为根目录。123456789101112/** * path.js */var path = require('path');// 使用 path.joinconsole.log(path.join(__dirname, '/hexo'));// 输出 /home/whbxyr/test/hexo// 使用 path.resolveconsole.log(path.resolve(__dirname, '/hexo'));// 输出 /hexo &emsp;&emsp;path.join 的第二个参数前面有个&#39;/&#39;，但是输出的结果也仅仅是简单的当前路径的连接，而 path.resolve 的第二个参数前面也有&#39;/&#39;，但是由于它将其视为根目录，因此第二个参数的绝对路径便直接是根目录下的。 总结&emsp;&emsp;path.join 与 path.resolve 虽然有时候运行结果是相同的，有些情况下使用哪个都可以，但是它们二者之间还是有本质区别的，我们在平常的使用中应该要多加注意，加以区分。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"},{"name":"node","slug":"node","permalink":"http://www.whbxyr.cn/tags/node/"}]},{"title":"各大浏览器内核(渲染引擎/JS引擎)","slug":"browserCore","date":"2017-04-15T07:17:16.000Z","updated":"2018-06-01T15:16:53.560Z","comments":true,"path":"2017/04/15/browserCore/","link":"","permalink":"http://www.whbxyr.cn/2017/04/15/browserCore/","excerpt":"","text":"简介&emsp;&emsp;在介绍各个主流的浏览器内核之前，首先介绍浏览器内核的组成及其工作原理/作用。 &emsp;&emsp;渲染引擎(又叫排版引擎)以及JS引擎是浏览器内核的两个组成部分。 &emsp;&emsp;渲染引擎负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用PDF阅读器插件（所以想做浏览器插件的同学必须知道浏览器的工作原理），可以显示PDF格式。 &emsp;&emsp;JS引擎负责对JavaScript进行解释、编译和执行，以使网页达到一些动态的效果。 渲染引擎一. Trident/EdgeHTML -&gt; (IE浏览器/Edge浏览器) &emsp;&emsp;Trident是微软的IE浏览器使用的渲染引擎，它是从从早期一款商业性的专利网页浏览器Spyglass Mosaic派生出来的。Window 10发布之后，微软将其内置的浏览器命名为Edge，而Edge浏览器的渲染引擎便是EdgeHTML。 二. WebKit（WebCore） -&gt; (Safari浏览器) &emsp;&emsp;WebKit是苹果公司的Safari浏览器使用的渲染引擎，是KDE（Linux桌面系统）小组的KHTML引擎的一个开源的分支。 三. Chromium/Blink -&gt; (Chrome浏览器) &emsp;&emsp;Chromium是谷歌公司的Chrome浏览器使用的渲染引擎，它是以苹果公司的WebKit作为原型的，是WebKit的一个分支。Chromium引擎把WebKit引擎的代码梳理得更加可读。后来，在2013年的时候，Chrome放弃了Chromium引擎转而使用了基于WebKit2的Blink引擎，其中WebKit2是苹果公司于2010年推出的新的WebKit引擎。 四. Presto -&gt; (Opera浏览器) &emsp;&emsp;Presto是挪威Opera Software ASA公司的Opera浏览器使用的渲染引擎，后来该公司为了减少研发成本，跟随Chrome浏览器先后将渲染引擎改为Chromium 和 Blink。 五. Gecko -&gt; (FireFox浏览器) &emsp;&emsp;Gecko是Mozilla公司的FireFox浏览器使用的渲染引擎，它是一款开源的跨平台渲染引擎，可以在Windows、 BSD、Linux 和 Mac OS X 中使用。 JS引擎一. 微软的JS引擎 JScript Chakra IE3.0-IE8.0 IE9+ 二. 苹果的JS引擎 Nitro 为Safari 4编写 三. Google的JS引擎 V8 开放源代码，由Google丹麦开发，是Chrome浏览器的一部分 四. Opera的JS引擎 Linear A Linear B Futhark Carakan Opera 4.0～6.1 Opera 7.0～9.2 Opera 9.5～10.2 Opera10.50+ 五. Mozilla的JS引擎 SpiderMonkey Rhino TraceMonkey JaegerMonkey JavaScriptCore、WebKit IonMonkey OdinMonkey 第一款JavaScript引擎 完全以Java编写 基于实时编译的引擎 结合追踪和组合码技术大幅提高性能 用于Mozilla Firefox 4.0以上版本 可以对JavaScript编译后的结果进行优化 可以对asm.js进行优化，用于Mozilla Firefox 22.0以上版本","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://www.whbxyr.cn/tags/浏览器/"}]},{"title":"详解应用层协议之 HTTP 协议","slug":"HTTPprotocol","date":"2017-04-14T04:17:11.000Z","updated":"2018-06-01T15:16:53.544Z","comments":true,"path":"2017/04/14/HTTPprotocol/","link":"","permalink":"http://www.whbxyr.cn/2017/04/14/HTTPprotocol/","excerpt":"","text":"&emsp;&emsp;HTTP 协议定义了浏览器（万维网客户端）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。从层次的角度看，HTTP 协议是面向事务的应用层协议，它是万维网上能够可靠地交换文件（包括文本/声音/图像等各种多媒体文件）的重要基础。 (一) http协议的特点 http是面向事务/无状态/无连接的协议 http报文分请求报文和响应报文两种 http的发展路线：0.9 ~ 1.0 ～ 1.1 ～ 2.0 (二) http报文的分类http报文分两类，包括请求报文以及响应报文，两种报文的格式都由三部分组成，包括开始行/首部行/实体主体 三部分。（1）请求报文 即浏览器（万维网客户端）向万维网服务器发送的报文。请求报文中的开始行也称作 请求行，首部行又叫做请求报文的 请求头，实体主体（请求主体）又叫做 http实体（包含首部行和实体主体两部分）的实体主体。各部分的详细格式信息如下图： &emsp;&emsp;例子： &emsp;&emsp;GET /562f25980001b1b106000338.jpg HTTP/1.1&emsp;&emsp;Host img.mukewang.com&emsp;&emsp;User-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36&emsp;&emsp;Accept image/webp,image/,/*;q=0.8&emsp;&emsp;Referer http://www.imooc.com/&emsp;&emsp;Accept-Encoding gzip, deflate, sdch&emsp;&emsp;Accept-Language zh-CN,zh;q=0.8 （2）响应报文 即万维网服务器向浏览器（万维网客户端）发送的报文。响应报文中的开始行也称作状态行，首部行又叫做请求报文的 响应头，实体主体（响应主体）又叫做 http实体（包含首部行和实体主体两部分）的实体主体。各部分的详细格式信息如下图： &emsp;&emsp;例子： &emsp;&emsp;HTTP/1.1 200 OK&emsp;&emsp;Date: Fri, 22 May 2009 06:07:21 GMT&emsp;&emsp;Content-Type: text/html; charset=UTF-8&emsp;&emsp;&emsp;&emsp;&lt;html&gt;&emsp;&emsp;&lt;head&gt;&lt;/head&gt;&emsp;&emsp;&lt;body&gt;&emsp;&emsp;&lt;!--body goes here--&gt;&emsp;&emsp;&lt;/body&gt;&emsp;&emsp;&lt;/html&gt; (三) http报文的状态码（响应报文产生的）http响应报文产生的状态码主要分五类，如下：（1）1xx，表示通知信息的，如请求收到了或正在进行处理。包括 100 - 102 。（2）2xx，表示成功，如接受或知道了。包括 200 - 207 。（3）3xx，表示重定向，如要完成请求还必须采取进一步的行动。包括 300 - 307 。（4）4xx，表示客户的差错，如请求中有错误的语法或不能完成。包括 400 - 418 、421 - 426、449、451。（5）5xx，表示服务器的差错，如服务器失效无法完成请求。包括 500 - 507、509 - 510。其中，还有一个比较少见的状态码 600，它代表万维网服务器只返回了响应主体而没有返回响应头。 (四) http协议中的相关称谓 请求头/响应头（header），即首部行。 http实体，即由首部行（header）以及实体主体（body）两部分组成的，不包括开始行。","categories":[{"name":"技术类-网络协议","slug":"技术类-网络协议","permalink":"http://www.whbxyr.cn/categories/技术类-网络协议/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://www.whbxyr.cn/tags/网络协议/"}]},{"title":"ubuntu下配置 Cisco VPN 的方法","slug":"ubuntuVpn","date":"2017-04-13T06:12:31.000Z","updated":"2018-06-01T15:16:53.591Z","comments":true,"path":"2017/04/13/ubuntuVpn/","link":"","permalink":"http://www.whbxyr.cn/2017/04/13/ubuntuVpn/","excerpt":"","text":"（一） 命令行安装并使用 Cisco VPN1. 连接 Cisco VPN&emsp;&emsp;切换到root后安装vpnc并设置各项参数1234567// 切换到root$ su// 安装vpnc# apt-get install vpnc// 使用vpnc命令并设置参数# vpnc// 之后按照提示输入各项设置，可见下图 2. 查看 Cisco VPN12// 使用命令 ifconfig 查看 Cisco VPN 连接情况# ifconfig 3. 断开 Cisco VPN12// 使用命令 vpnc-disconnect 断开 Cisco VPN# vpnc-disconnect （二）图形界面配置 Cisco VPN（需要先安装）第一步： 命令行安装图形化的 Cisco VPN1$ sudo apt-get install network-manager-vpnc network-manager-vpnc-gnome 第二步： 打开Network Connections 并选择 Cisco Compatible VPN(vpnc)，如下图 第三步： 点击 Create… 后进行配置，配置的参数包括 Gateway(网关)，User name(用户名)，User password(喻户密码)，Group name(组名称)，Group password(组密码)，配置完成后点击 Save 保存设置。如下图： 第三步： 点击 VPN Connections 并选择刚刚设置的 Cisco VPN（比如 VPN connection 1），若能看到以下标志，则说明成功链接 Cisco VPN","categories":[{"name":"技术类-linux","slug":"技术类-linux","permalink":"http://www.whbxyr.cn/categories/技术类-linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://www.whbxyr.cn/tags/ubuntu/"},{"name":"奇淫巧技","slug":"奇淫巧技","permalink":"http://www.whbxyr.cn/tags/奇淫巧技/"}]},{"title":"ubuntu下各种出错情况的解决方法","slug":"ubuntuTip","date":"2017-04-13T05:51:05.000Z","updated":"2018-06-01T15:16:53.591Z","comments":true,"path":"2017/04/13/ubuntuTip/","link":"","permalink":"http://www.whbxyr.cn/2017/04/13/ubuntuTip/","excerpt":"","text":"1. 网络连接报错“device not managed”第一步: 编辑/etc/NetworkManager/NetworkManager.conf：1$ sudo gedit /etc/NetworkManager/NetworkManager.conf 将其中的managed=false改为managed=true 第二步: 重启network-manager service：1$ sudo service network-manager restart 2. Ubuntu下Sublime Text 3解决无法输入中文的方法第一步: 更新并升级系统为最新(较新的系统会解决很多可能出现的问题)1$ sudo apt-get update &amp;&amp; sudo apt-get upgrade 第二步: 克隆项目到本地1$ git clone https://github.com/lyfeyaj/sublime-text-imfix.git 第三步: 运行脚本1$ cd sublime-text-imfix &amp;&amp; ./sublime-imfix 完成! 重新启动后就可以在 Sublime Text 2/3 中 使用 Fcitx了! 注意: 皮肤可能需要自己选择。效果图如下： 3. Ubuntu下解决搜狗输入法无法正常输入中文的方法第一步: 找到搜狗输入法的配置文件12$ cd ~$ cd .config/ 找到的搜狗输入法的配置文件如下图： 第二步: 删除有关搜狗输入法的配置文件123$ rm -rf SogouPY$ rm -rf SogouPY.users$ rm -rf sogou-qimpanel 第三步: 操作系统注销后重新登录，搜狗输入法即可恢复正常 4. Ubuntu下安装 Node 版本管理器nvm的方法12// 执行以下命令，等待安装完成后重启terminal，即可使用nvm安装、使用和管理各种版本的node和npm$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.29.0/install.sh | bash","categories":[{"name":"技术类-linux","slug":"技术类-linux","permalink":"http://www.whbxyr.cn/categories/技术类-linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://www.whbxyr.cn/tags/ubuntu/"},{"name":"奇淫巧技","slug":"奇淫巧技","permalink":"http://www.whbxyr.cn/tags/奇淫巧技/"}]},{"title":"JavaScript事件循环机制高级篇","slug":"EventLoopUp","date":"2017-04-09T11:33:07.000Z","updated":"2018-06-01T15:16:53.529Z","comments":true,"path":"2017/04/09/EventLoopUp/","link":"","permalink":"http://www.whbxyr.cn/2017/04/09/EventLoopUp/","excerpt":"","text":"&emsp;&emsp;在上一篇文章JavaScript事件循环机制入门篇当中，我们对JavaScript的事件循环机制进行了初步的了解，熟悉了JavaScript的函数调用栈以及任务队列的定义和作用，并指出JavaScript的任务队列分为宏任务(macro-task)和微任务(micro-task)两种，如下： 1.macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering 2.micro-task包括：process.nextTick, Promises, Object.observe(已废弃), MutationObserver(html5新特性) &emsp;&emsp;这篇文章里，我们就以一段测试代码来感受一下JavaScript事件循环机制的“复杂过程”。测试代码如下：（依然是借鉴的别人的例子）12345678910111213(function test() &#123; setTimeout(function () &#123;console.log(4)&#125;, 0); new Promise(function executor(resolve) &#123; console.log(1); for (var i = 0; i &lt; 10000; i++) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(2); &#125;).then(function () &#123; console.log(5); &#125;); console.log(3);&#125;)(); 1.首先，script任务源先执行，全局上下文入栈。2.script任务源的代码在执行时遇到setTimeout,作为一个macro-task，将其回调函数放入自己的队列之中。3.script任务源的代码在执行时遇到Promise实例。Promise构造函数中的第一个参数是在当前任务直接执行不会被放入队列之中，因此此时输出 1 。4.在for循环里面遇到resolve函数，函数入栈执行之后出栈，此时Promise的状态变成Fulfilled。代码接着执行遇到console.log(2),输出2。5.接着执行，代码遇到then方法，其回调函数作为micro-task入栈，进入Promise的任务队列之中。6.代码接着执行，此时遇到console.log(3),输出3。7.输出3之后第一个宏任务script的代码执行完毕，这时候开始开始执行所有在队列之中的micro-task。then的回调函数入栈执行完毕之后出栈，这时候输出58.这时候所有的micro-task执行完毕，第一轮循环结束。第二轮循环从setTimeout的任务队列开始，setTimeout的回调函数入栈执行完毕之后出栈，此时输出4。 总结 任务分宏任务和微任务两种，它们（回调函数）被放入不同的任务队列中。 对一段代码，先执行宏任务中的一个任务队列，等到这个任务队列中的函数从函数调用栈中清空时，再执行微任务。 等到所有的微任务执行完毕后，再从宏任务中的一个任务队列开始执行。 JavaScript事件循环机制就是按照以上3步循环执行的。 提问？&emsp;&emsp;如果在宏任务或者微任务里面再嵌套进去一个或者多个宏任务或者微任务，事件循环机制又是怎么处理的呢？比如以下测试代码的输出情况就有三种： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849console.log('glob1');setImmediate(function () &#123; console.log('immediate1'); process.nextTick(function () &#123; console.log('immediate1_nextTick'); &#125;); new Promise(function (resolve) &#123; console.log('immediate1_promise'); resolve(); &#125;).then(function () &#123; console.log('immediate1_then'); &#125;); setTimeout(function () &#123; console.log('immediate1_timeout1'); &#125;); setImmediate(function () &#123; console.log('immediate1_immediate1'); &#125;);&#125;);setTimeout(function () &#123; console.log('timeout1'); process.nextTick(function () &#123; console.log('timeout1_nextTick'); &#125;); new Promise(function (resolve) &#123; console.log('timeout1_promise'); resolve(); &#125;).then(function () &#123; console.log('timeout1_then'); &#125;); setTimeout(function () &#123; console.log('timeout1_timeout1'); process.nextTick(function () &#123; console.log('timeout1_timeout1_nextTick'); &#125;); setImmediate(function () &#123; console.log('timeout1_setImmediate1'); &#125;); &#125;);&#125;);new Promise(function (resolve) &#123; console.log('glob1_promise'); resolve();&#125;).then(function () &#123; console.log('glob1_then');&#125;);process.nextTick(function () &#123; console.log('glob1_nextTick');&#125;); 第一种输出情况：1234567891011121314151617glob1glob1_promiseglob1_nextTickglob1_thentimeout1timeout1_promisetimeout1_nextTicktimeout1_thenimmediate1immediate1_promiseimmediate1_nextTickimmediate1_thentimeout1_timeout1timeout1_timeout1_nextTickimmediate1_immediate1timeout1_setImmediate1immediate1_timeout1 第二种输出情况：1234567891011121314151617glob1glob1_promiseglob1_nextTickglob1_thentimeout1timeout1_promisetimeout1_nextTicktimeout1_thenimmediate1immediate1_promiseimmediate1_nextTickimmediate1_thenimmediate1_immediate1timeout1_timeout1immediate1_timeout1timeout1_timeout1_nextTicktimeout1_setImmediate1 第三种输出情况：1234567891011121314151617glob1glob1_promiseglob1_nextTickglob1_thentimeout1timeout1_promisetimeout1_nextTicktimeout1_thenimmediate1immediate1_promiseimmediate1_nextTickimmediate1_thentimeout1_timeout1immediate1_timeout1timeout1_timeout1_nextTickimmediate1_immediate1timeout1_setImmediate1 本人还不是特别理解这些情况，如果您了解的话，请不吝赐教！我的工作邮箱：**raywhbxyr@163.com** 参考资料深入浅出Javascript事件循环机制(上)深入浅出JavaScript事件循环机制(下)前端基础进阶（十二）：深入核心，详解事件循环机制JavaScript：彻底理解同步、异步和事件循环(Event Loop)","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"}]},{"title":"JavaScript事件循环机制入门篇","slug":"EventLoop","date":"2017-04-09T05:20:09.000Z","updated":"2018-06-01T15:16:53.513Z","comments":true,"path":"2017/04/09/EventLoop/","link":"","permalink":"http://www.whbxyr.cn/2017/04/09/EventLoop/","excerpt":"","text":"函数调用栈和任务队列&emsp;&emsp;Javascript有一个函数调用栈（call-stack），当在函数调用栈中执行某一个task时，其他的task都要等着，直到这个task执行完成并从函数调用栈中出栈（函数调用栈此时为空）时，下一个task才可以进入函数调用栈中执行。 &emsp;&emsp;而JavaScript是单线程的，当在执行过程中遇到一些类似于setTimeout等异步操作的时候，会交给浏览器的其他模块(以webkit为例，是webcore模块)进行处理，当到达setTimeout指定的延时执行的时间之后，task(回调函数)会放入到任务队列之中。不同的异步任务的回调函数会放入不同的任务队列之中，比如宏任务和微任务（如下所示）。两者中，前者为宏任务，后者为微任务，在事件循环中的执行顺序均为从左到右。 1.macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering 2.micro-task包括：process.nextTick, Promises, Object.observe(已废弃), MutationObserver(html5新特性) 等到函数调用栈中所有task执行完毕之后，接着去执行其它任务队列之中的task。下图展示了大致的执行流程以及结构：&emsp;&emsp;由上图可知，函数调用栈中遇到DOM操作/ajax请求或者setTimeout等WebAPIs的时候就会交给浏览器内核的其他模块进行处理，webkit内核在Javasctipt执行引擎之外，有一个重要的模块是webcore模块。对于图中WebAPIs提到的三种API，webcore分别提供了DOM Binding、network、timer模块来处理底层实现。等到这些模块处理完这些操作的时候将回调函数放入任务队列中，之后等栈中的task执行完之后再去执行以上任务队列之中的回调函数。 以setTimeout为例观察事件循环机制（借鉴别人的）1.首先main()函数的执行上下文入栈。2.代码接着执行，遇到console.log(‘Hi’),此时log(‘Hi’)入栈，console.log方法只是一个webkit内核支持的普通的方法，所以log(‘Hi’)方法立即被执行。此时输出’Hi’。3.当遇到setTimeout的时候，执行引擎将其添加到栈中。4.调用栈发现setTimeout是之前提到的WebAPIs中的API，因此将其出栈之后将延时执行的函数交给浏览器的timer模块进行处理。5.timer模块去处理延时执行的函数，此时执行引擎接着执行将log(‘SJS’)添加到栈中，此时输出’SJS’。6.当timer模块中延时方法规定的时间到了之后就将其放入到任务队列之中，此时调用栈中的task已经全部执行完毕。7.任务队列中的回调函数调入函数调用栈中执行。8.执行具体的内部程序。 总结&emsp;&emsp;本文简单讲解了JavaScript事件循环机制的原理，主要几点如下： &emsp;&emsp;1.所有的代码都要通过函数调用栈中调用执行。&emsp;&emsp;2.当遇到前文中提到的APIs的时候，会交给浏览器内核的其他模块进行处理。&emsp;&emsp;3.任务队列中存放的是回调函数。&emsp;&emsp;4.等到调用栈中的task执行完之后再回去执行任务队列之中的task。 &emsp;&emsp;本文只能算是入门，若想深入了解JavaScript的事件循环机制，可见我的下一篇文章JavaScript事件循环机制高级篇 参考资料深入浅出Javascript事件循环机制(上)深入浅出JavaScript事件循环机制(下)前端基础进阶（十二）：深入核心，详解事件循环机制JavaScript：彻底理解同步、异步和事件循环(Event Loop)","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"}]},{"title":"为hexo博客添加独立域名","slug":"hexoCname","date":"2017-04-04T05:07:04.000Z","updated":"2018-06-01T15:16:53.575Z","comments":true,"path":"2017/04/04/hexoCname/","link":"","permalink":"http://www.whbxyr.cn/2017/04/04/hexoCname/","excerpt":"","text":"一共需要两个步骤：1.添加一条CNAME记录，主机记录随便写（根据个人需要，比如www，url便为www.域名.根域名），记录值为你的github page的地址，比如我的就是whbxyr.github.io。如下图：2.在你放置hexo博客的github仓库的Settings里设置Custom domain，设置为你要的url，比如我的就是www.whbxyr.cn，如下图： 或者在你的本地hexo博客目录下的source文件夹里添加一个文件，文件名为CNAME，在其中输入你的域名，比如我的就是www.whbxyr.cn，如下图：","categories":[{"name":"技术类-奇淫巧技","slug":"技术类-奇淫巧技","permalink":"http://www.whbxyr.cn/categories/技术类-奇淫巧技/"}],"tags":[{"name":"奇淫巧技","slug":"奇淫巧技","permalink":"http://www.whbxyr.cn/tags/奇淫巧技/"}]},{"title":"Ubuntu下彻底卸载软件的方法","slug":"aptRemove","date":"2017-04-03T10:14:15.000Z","updated":"2018-06-01T15:16:53.560Z","comments":true,"path":"2017/04/03/aptRemove/","link":"","permalink":"http://www.whbxyr.cn/2017/04/03/aptRemove/","excerpt":"","text":"在介绍一般的彻底卸载软件的命令前，先介绍一些卸载命令的作用1.删除软件包（保留配置文件），但不删除该软件依赖的包1$ sudo apt-get remove &lt;package&gt; 2.删除软件包（不保留配置文件），但不删除该软件依赖的包1$ sudo apt-get --purge remove &lt;package&gt; 3.删除软件后再删除依赖包（保留配置文件）1$ sudo apt-get autoremove &lt;package&gt; 4.删除 /var/cache/apt/archives/ 已经过期的deb1$ sudo apt-get autoclean &lt;package&gt; 5.删除 /var/cache/apt/archives/ 中所有的deb1$ sudo apt-get clean 一般彻底卸载软件的命令及使用顺序如下123456// 删除软件及其配置文件$ sudo apt-get --purge remove &lt;package&gt;// 删除已经不再依赖的软件依赖包$ sudo apt-get autoremove &lt;package&gt;// 删除此时dpkg列表中有“rc”状态的软件包$ sudo dpkg -l | grep ^rc | awk '&#123;print $2&#125;' | sudo xargs dpkg -P","categories":[{"name":"技术类-linux","slug":"技术类-linux","permalink":"http://www.whbxyr.cn/categories/技术类-linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://www.whbxyr.cn/tags/ubuntu/"}]},{"title":"es6(一) 之 let 和 const 命令","slug":"letncst","date":"2016-12-26T06:27:31.000Z","updated":"2018-06-01T15:16:53.575Z","comments":true,"path":"2016/12/26/letncst/","link":"","permalink":"http://www.whbxyr.cn/2016/12/26/letncst/","excerpt":"","text":"（一）let命令以及块级作用域(1) let命令声明的变量只在所在的代码块内有效(2) for循环的循环语句是一个父级作用域，而循环体内部是一个单独的子作用域(3) for循环的每次循环中的变量i都是重新声明的，作用域之间无关系(4) 不存在声明提前，在声明之前使用变量会报错“ReferenceError: i is not defined”(5) 存在暂时性死区，只要块级作用域内存在let命令，它所声明的变量就”绑定“（binding）这个区域，不再受外部的影响。 因为“暂时性死区”的存在，使得typeof不再是一个百分之百安全的操作12typeof x; // ReferenceErrorlet x; // 在x声明之前，都属于x的死区，只要用到该变量就会报错 (6) 不允许重复声明。let不允许在相同作用域内，重复声明同一个变量。let、var以及const三者是不允许在相同作用域内声明同一个变量的。123456789101112131415161718192021// 报错function () &#123; let a = 10; var a = 1;&#125;// 报错function () &#123; let a = 10; let a = 1;&#125;function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; (7) ES6 块级作用域的实现实际上使得广泛应用的立即执行函数表达式（IIFE）不再必要了。1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; (8) 块级作用域与函数声明。 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域中声明。但是浏览器为了兼容以前的旧代码，还是支持在块级作用域之中声明函数。 ES6 引入了块级作用域，明确允许在块级作用域中声明函数，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。但是为了减轻因此产生的不兼容问题，ES6 在附录B中规定： 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。 以上三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当左let处理。1234567891011121314151617181920212223242526// 浏览器的 ES6 环境function f() &#123; console.log('I am outside!');&#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f(); // Uncaught TypeError: f is not a function&#125;())// 相当于(function () &#123; var f = undefined; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f(); // Uncaught TypeError: f is not a function&#125;()) (9) 另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。12345678910// 不报错'use strict';if (true) &#123; function f() &#123;&#125;&#125;// 报错'use strict';if (true) function f() &#123;&#125; （二）const命令(1) const 命令除了不适用于循环之外，拥有let 命令的所有特性。(2) const 本质上并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。12345678910111213141516171819const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: \"foo\" is read-onlyconst a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错// 如果真的想将对象冻结，应该使用Object.freeze方法。const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; (3) 以下展示的是将一个对象彻底冻结的函数。12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;;","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"},{"name":"es6","slug":"es6","permalink":"http://www.whbxyr.cn/tags/es6/"}]},{"title":"利用tinymce编写网页文章并插入到MySQL数据库","slug":"tinymce-MySQL","date":"2016-10-04T10:23:22.000Z","updated":"2018-06-01T15:16:53.591Z","comments":true,"path":"2016/10/04/tinymce-MySQL/","link":"","permalink":"http://www.whbxyr.cn/2016/10/04/tinymce-MySQL/","excerpt":"","text":"tinymce是一个轻量级的基于浏览器的所见即所得编辑器，由JavaScript写成。以下我将为大家介绍如何使用JavaScript的Ajax、配合使用php将tinymce中编写的文章经过转码后顺利存储进MySQL数据库。（将文章数据库表设计为只有两个字段，一个是int型的自增长id字段，另一个是text类型的article字段） 第一步：在你的网站根目录（或者其他网站目录也行）下新建一个editor.html文件，编辑代码如下：1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;tinymce编辑文章&lt;/title&gt; &lt;script src=\"http://cdn.tinymce.com/4/tinymce.min.js\"&gt;&lt;script&gt; &lt;script src=\"./event.js\"&gt;&lt;/script&gt; &lt;script src=\"./htmlcode.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;textarea id=\"editor\" name=\"content\"&gt;&lt;/textarea&gt; &lt;input id=\"handin\" type=\"button\" value=\"提交\"&gt;&lt;/body&gt;&lt;/html&gt; 这个文件将tinymce文章编辑器插件成功应用到我们的页面当中,并添加了一个用于提交文章到数据库的“提交”按钮。 其中引入的event.js文件代码如下，应将其置于同一目录下。它是一个为DOM添加事件处理的兼容脚本。1234567891011121314151617/** * 为DOM添加事件处理的兼容脚本 * /var EventUtil = &#123; // 添加句柄 addHandler: function (element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent('on'+type, handler); &#125; else &#123; element['on'+type] = handler; &#125; &#125;&#125; 其中引入的htmlcode.js文件代码如下，同样将其置于editor.html同一目录下。它是一个实现html转码的脚本。1234567891011121314151617181920212223242526/** * 用浏览器内部转换器实现 * javascript处理HTML的Encode(转码)和Decode(解码) */var HtmlUtil = &#123; // 用浏览器内部转换器实现html转码 // 首先动态创建一个容器标签元素，如DIV， // 然后将要转换的字符串设置为这个元素的innerText(ie支持) // 或者textContent(火狐，google支持)，最后返回这个元素的innerHTML， // 即得到经过HTML编码转换的字符串了。 htmlEncode: function (html) &#123; var div = document.createElement('div'); div.appendChild(document.createTextNode(html)); return div.innerHTML; &#125;, // 用浏览器内部转换器实现html解码 // 首先动态创建一个容器标签元素，如DIV， // 然后将要转换的字符串设置为这个元素的innerHTML(ie，火狐，google都支持)， // 最后返回这个元素的innerText(ie支持)或者textContent(火狐，google支持)， // 即得到经过HTML解码的字符串了。 htmlDecode: function (text) &#123; var div = document.createElement('div'); div.innerHTML = text; return div.innerText || div.textContent; &#125; &#125; 第二步：将以下代码插入到editor.html文件的底部，其实就是一些用script标签包起来的JavaScript代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344EventUtil.addHandler(document.getElementById('handin'), 'click', function () &#123; // 创建一个XMLHttpRequest对象 var request = new XMLHttpRequest(); // 对articleToDB.php文件发出POST请求 request.open('POST', './articleToDB.php'); // ajax传过去的参数都会被处理为字符串，因此不需要再将参数转换为字符串 // 先进行“去\\n”操作，再进行html编码，使用的是浏览器内部转换器 var article = HtmlUtil.htmlEncode((tinyMCE.activeEditor.getContent()).replace(/[\\n]/ig, '')); // tinyMCE.activeEditor.getContent()方法会在我们写的文章里面的每一个\\前再加一个\\ // 当我们在文章里只写了一个\\时， // tinyMCE.activeEditor.getContent()方法给我们多加了一个\\ // 此时就有了两个\\，但是正则表达式不会匹配第一个作为转义字符作用的反斜杠'\\'， // 在用正则表达式匹配字符串时，转义符相当于不存在 // 因此在这里用正则匹配时就只需要4个转义符 // 用replace()方法将其替换为4个\\ // 即符合mysql数据库3个转义符转义一个字符的规则 article = article.replace(/\\\\/g, '\\\\\\\\'); // 将获取的html代码中的\"替换为\\\\\\\" // 这样ajax才能正确读取参数并将其完整插入数据库 article = article.replace(/[\"]/g, '\\\\\\\"'); // 对处理完的字符串进行最终的编码，去除取值符等敏感字符对ajax传值的影响 article = encodeURIComponent(article); // 拼接请求主体 var data = 'article=' + article; // POST请求方式必须设置的请求头格式 request.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); request.send(data); request.onreadystatechange = function () &#123; if (request.readyState === 4) &#123; if (request.status === 200) &#123; // 弹出相关文字提示 alert(request.responseText); &#125; else &#123; // 当请求不到数据时就会导致错误，用以下方法显示 alert('发生错误：' + request.status); &#125; &#125; &#125;&#125;); 第三步：编写articleToDB.php文件实现文章插入MySQL数据库，并将其置于editor.html同一目录下。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phpheader('Content-Type: application/json; charset=utf-8');// 若取不到值，那么进行相应的信息反馈并结束if (!isset($_POST['article']) || empty($_POST['article'])) &#123; echo '您还没有编辑文章'; exit;&#125;// 面向对象的建立数据库连接的方法// 应该填写服务器数据库的主机名，用户名以及相对应的密码// 比如$db = new mysqli('localhost','root','123456789');$db = new mysqli('主机名','用户名','密码');if (mysqli_connect_errno()) &#123; echo '连接数据库失败，请稍后重试！'; exit;&#125;// 判断数据库是否存在$select = $db-&gt;select_db('article');if (!$select) &#123; // 创建数据库失败后的处理提示 $createDB_query = 'create database article'; $createDB = $db-&gt;query($createDB_query); if (!$createDB) &#123; echo '创建数据库失败'; exit; &#125; //使用数据库失败后的处理提示 $useDB_query = 'use article'; $useDB = $db-&gt;query($useDB_query); if (!$useDB) &#123; echo '使用数据库失败'; exit; &#125; else &#123; echo '成功'; exit; &#125;&#125;// 设置数据库编码$db-&gt;query('set names utf8');// 此处在接收到经过编码的article后，通过=操作符，实现了解码$article = $_POST['article'];$insert_query = 'insert into text2 values(NULL, \"'.$article.'\")';$insert_result = $db-&gt;query($insert_query);// 对返回结果进行判断if ($insert_result) &#123; echo '成功！管理员文章发布成功！';&#125;else &#123; echo '失败！管理员文章发布失败！';&#125;// 关闭数据库连接$db-&gt;close(); 以上三步便是利用JavaScript的Ajax、配合使用php将tinymce中编写的文章经过转码后顺利存储进MySQL数据库的全过程，需要注意的点有以下几个： 1. html代码必须经过转码后才能插入数据库; 2. 字符串’\\\\’长度为1而不是2; 3. 正则表达式匹配字符串时并不匹配起转义字符作用的反斜杠’\\’; 4. 在插入MySQL数据库时，3个转义字符转义一个字符","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://www.whbxyr.cn/tags/插件/"}]},{"title":"兼容浏览器的事件处理程序 EventUtil","slug":"EventUtil","date":"2016-06-24T10:06:56.000Z","updated":"2018-06-01T15:16:53.544Z","comments":true,"path":"2016/06/24/EventUtil/","link":"","permalink":"http://www.whbxyr.cn/2016/06/24/EventUtil/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113var EventUtil = &#123; // 获取事件对象，兼容IE getEvent: function (event) &#123; return event ? event : window.event; &#125;, // 获取事件目标，兼容IE getTarget: function (event) &#123; return event.target || event.srcElement; &#125;, // 阻止默认事件，兼容IE preventDefault: function (event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 阻止事件冒泡，兼容IE stopPropagation: function (event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;, // 注册事件 addHandler: function (element, type, handler) &#123; if (element.addEventListener) &#123; // DOM2级的事件处理程序，最后一个参数为false，设置该事件处理程序在事件流的冒泡阶段触发 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent)&#123; // IE的事件处理程序 element.attachEvent('on' + type, handler); &#125; else &#123; // DOM0级的事件处理程序 element['on' + type] = handler; &#125; &#125;, // 删除事件 removeHandler: function (element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent('on' + type, handler); &#125; else &#123; element['on' + type] = null; &#125; &#125;, // 获取事件(mouseover, mouseout)相关元素的信息 getRelatedTarget: function (event) &#123; if (event.relatedTarget) &#123; return event.relatedTarget; &#125; else if (event.toElement) &#123; return event.toElement; &#125; else if (event.fromElement) &#123; return event.fromElement; &#125; else &#123; return null; &#125; &#125;, // 获取鼠标点击事件的鼠标按钮 getButton: function (event) &#123; if (document.implementation.hasFeature('MouseEvents', '2.0')) &#123; return event.button; &#125; else &#123; switch (event.button) &#123; case 0: case 1: case 3: case 5: case 7: // 返回0表示主鼠标按钮 return 0; case 2: case 6: // 返回2表示次鼠标按钮 return 2; case 4: // 返回1表示中间的鼠标按钮 return 1; &#125;; &#125; &#125;, // 获取mousewheel事件的wheelDelta或者detail属性 getWheelDelta: function (event) &#123; if (event.wheelDelta) &#123; return (client.engine.opera &amp;&amp; client.engine.opera &lt; 9.5 ? -event.wheelDelta : event.wheelDelta); &#125; else &#123; return -event.detail * 40; &#125; &#125;, // 获取键盘事件的字符编码 getCharCode: function (event) &#123; if (typeof event.charCode === 'number') &#123; return event.charCode; &#125; else &#123; return event.keyCode; &#125; &#125;&#125;;","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://www.whbxyr.cn/tags/DOM/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"}]},{"title":"异步加载 javascript 文件的方法总结","slug":"asyncJs","date":"2016-04-28T14:36:51.000Z","updated":"2018-06-01T15:16:53.560Z","comments":true,"path":"2016/04/28/asyncJs/","link":"","permalink":"http://www.whbxyr.cn/2016/04/28/asyncJs/","excerpt":"","text":"异步加载 javascript 文件的方法","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"}]},{"title":"事件流概述","slug":"event","date":"2016-04-24T09:38:56.000Z","updated":"2018-06-01T15:16:53.560Z","comments":true,"path":"2016/04/24/event/","link":"","permalink":"http://www.whbxyr.cn/2016/04/24/event/","excerpt":"","text":"&emsp;&emsp;事件流描述的是从页面中接收事件的顺序，而 IE 和 Netscape 提出了差不多是完全相反的事件流的概念。IE 的事件流是事件冒泡，而 Netscape Communicator 的事件流是事件捕获。 IE的事件冒泡&emsp;&emsp;事件冒泡，即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。以下面的页面为例：123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Event Bubbling Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"myDiv\"&gt;Click Me&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; &emsp;&emsp;如果你单击了页面中的&lt;div&gt;元素，那么这个click事件会按照如下顺序传播：(1) &lt;div&gt;(2) &lt;body&gt;(3) &lt;html&gt;(4) document&emsp;&emsp;IE5.5 及更早的版本中的事件冒泡会跳过&lt;html&gt;元素（从&lt;body&gt;直接跳到document）。IE9、Firefox、Chrome 和 Safari 则将事件一直冒泡到 window 对象。 事件捕获&emsp;&emsp;事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件达到预定目标之前捕获它。如果仍以前面的HTML页面作为例子，那么单击&lt;div&gt;元素就会以下列顺序触发 click 事件：(1) document(2) &lt;html&gt;(3) &lt;body&gt;(4) &lt;div&gt;&emsp;&emsp;虽然事件捕获是 Netscape Communicator 唯一支持的事件流模型，但 IE9、Safari、Chrome、Opera 和 Firefox 目前也都支持这种事件流模型。尽管“DOM2级事件”规范要求事件应该从 document 对象开始传播，但这些浏览器都是从 window 对象开始捕获事件的。 由于老版本的浏览器不支持，因此很少有人使用事件捕获，建议使用事件冒泡，在有特殊需要的时候再使用事件捕获。DOM 事件流&emsp;&emsp;“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。它们的发生顺序如下：(1) 事件捕获，为截获事件提供了机会，这一过程不会传播到实际的事件目标(2) 实际的目标接收到事件，于是事件在此目标上发生，并在事件处理中被看成冒泡阶段的一部分(3) 冒泡阶段，可以在这个阶段对事件做出响应，然后事件又传播回文档。&emsp;&emsp;仍以前面的HTML页面作为例子，DOM2级事件流如下图： 事件处理程序：&emsp;&emsp;事件处理程序分HTML事件处理程序、DOM0级事件处理程序、DOM2级事件处理程序、IE事件处理程序四种。为了兼容各种浏览器，也催生出了跨浏览器的事件处理程序。 HTML事件处理程序&emsp;&emsp;示例如下：123456&lt;script&gt;function showMsg() &#123; alert('Hello world!');&#125;&lt;/script&gt;&lt;input type=\"button\" value=\"Click Me\" onclick=\"showMsg()\"&gt; DOM0级事件处理程序&emsp;&emsp;示例如下：12345var btn = document.getElementById('myBtn');btn.onclick = function () &#123; // 弹出“myBtn” alert(this.id);&#125; DOM2级事件处理程序&emsp;&emsp;示例如下：1234567var btn = document.getElementById('myBtn');var handler = function () &#123; alert(this.id);&#125;;btn.addEventListener('click', handler, false);// 指定事件处理程序的名称才能实现移除事件处理程序btn.removeEventListener('click', handler, false); IE事件处理程序&emsp;&emsp;示例如下：1234567var btn = document.getElementById('myBtn');var handler = function () &#123; alert(‘Clicked’);&#125;;btn.attachEvent('onclick', handler);// 指定事件处理程序的名称才能实现移除事件处理程序btn.detachEvent('onclick', handler); 跨浏览器的事件处理程序&emsp;&emsp;既然事件处理程序在不同浏览器上的实现方式不一样，那么能够跨浏览器的事件处理程序的存在就十分重要。关于跨浏览器的事件处理程序，可以观看我的另一篇文章——兼容浏览器的事件处理程序 EventUtil！ 总结在使用事件时，需要考虑如下一些内存与性能方面的问题。1.有必要限制一个页面中事件处理程序的数量，数量太多会导致占用大量内存，而且也会让用户感觉页面反应不够灵敏。2.建立在事件冒泡机制之上的事件委托技术，可以有效地减少事件处理程序的数量。3.建议在浏览器卸载页面之前移除页面中的所有事件处理程序。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://www.whbxyr.cn/tags/DOM/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"}]},{"title":"清除子元素浮动造成的影响","slug":"clearFloat","date":"2016-04-22T02:21:34.000Z","updated":"2019-04-18T15:43:59.967Z","comments":true,"path":"2016/04/22/clearFloat/","link":"","permalink":"http://www.whbxyr.cn/2016/04/22/clearFloat/","excerpt":"","text":"第一种：父级div设置高度12345678910111213&lt;style&gt;.father &#123; height: 200px;&#125;.son &#123; float: left; width: 20%; height: 200px;&#125;&lt;/style&gt;&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;浮动元素&lt;/div&gt;&lt;/div&gt; &emsp;&emsp;这种方法比较蠢，只是假象，如果子元素浮动的高度大于父元素，那么子元素依然会超出父元素的底部造成父元素高度塌陷的问题。 第二种：父级内部结尾处添加空的clear: both的div标签1234567891011121314&lt;style&gt;.son &#123; float: left; width: 20%; height: 200px;&#125;.clearfloat &#123; clear: both;&#125;&lt;/style&gt;&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;浮动元素&lt;/div&gt; &lt;div class=\"clearfloat\"&gt;&lt;/div&gt;&lt;/div&gt; &emsp;&emsp;这种方法实际上就是在底部强行加入了一个清除浮动的子元素。 第三种：父级使用伪类，类似第二种方法1234567891011121314151617181920&lt;style&gt;.father &#123; *zoom: 1;&#125;.father:after &#123; content: ''; display: block; clear: both; height: 0; overflow: hidden;&#125;.son &#123; float: left; width: 20%; height: 200px;&#125;&lt;/style&gt;&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;&lt;/div&gt;&lt;/div&gt; 或者使用下面的方法，也是使用了伪类123456789101112131415161718&lt;style&gt;.father &#123; *zoom: 1;&#125;.father:after &#123; content: ''; display: table; clear: both;&#125;.son &#123; float: left; width: 20%; height: 200px;&#125;&lt;/style&gt;&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;&lt;/div&gt;&lt;/div&gt; &emsp;&emsp;换汤不换药，底部的伪元素就相当于一个匿名的 div，只是他被附上了 clear: both; 的属性。 第四种：给父级添加overflow: hidden/auto/scroll;、float: left/right;、position: absolute;、display: inline-block;、zoom: 1;五个CSS属性其中之一1234567891011121314151617&lt;style&gt;.father &#123; overflow: hidden/auto/scroll; /*float: left/right;*/ /*position: absolute;*/ /*display: inline-block;*/ /*zoom: 1;*/&#125;.son &#123; float: left; width: 20%; height: 200px;&#125;&lt;/style&gt;&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;&lt;/div&gt;&lt;/div&gt; &emsp;&emsp;最后这个则是运用了 BFC（Block Formatting Context）的原理，使得父元素的表现就跟&lt;html&gt;一样，能包含万物（包括浮动了的子元素）。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"html","slug":"html","permalink":"http://www.whbxyr.cn/tags/html/"},{"name":"css","slug":"css","permalink":"http://www.whbxyr.cn/tags/css/"}]},{"title":"DOM详解","slug":"DOM","date":"2016-04-20T12:32:42.000Z","updated":"2018-06-01T15:16:53.513Z","comments":true,"path":"2016/04/20/DOM/","link":"","permalink":"http://www.whbxyr.cn/2016/04/20/DOM/","excerpt":"","text":"&emsp;&emsp;文档节点是每个文档的根节点，文档节点只有一个子节点，即&lt;html&gt;元素，我们称之为文档元素。文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。在HTML页面中，文档元素始终都是&lt;html&gt;元素。在XML中，没有预定义的元素，因此任何元素都可能成为文档元素。 &emsp;&emsp;接下来讲讲Node类型。DOM1级定义了一个Node接口，该接口将由DOM中的所有节点类型实现。这个Node接口在JavaScript中是作为Node类型实现的；除IE之外，在其他所有浏览器中都可以访问到这个类型。JavaScript中的所有节点类型都继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。每个节点都有一个nodeType属性，共有12种节点类型，每种类型都由Node类型中定义的一个数值常量来表示，如下：123456789101112Node.ELEMENT_NODE(1)Node.ATTRIBUTE_NODE(2)Node.TEXT_NODE(3)Node.CDATA_SECTION_NODE(4)Node.ENTITY_REFERENCE_NODE(5)Node.ENTITY_NODE(6)Node.PROCESSING_INSTRUCTION_NODE(7)Node.COMMENT_NODE(8)Node.DOCUMENT_NODE(9)Node.DOCUMENT_TYPE_NODE(10)Node.DOCUMENT_FRAGMENT_NODE(11)Node.NOTATION_NODE(12)","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://www.whbxyr.cn/tags/DOM/"},{"name":"html","slug":"html","permalink":"http://www.whbxyr.cn/tags/html/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"}]},{"title":"iframe的优缺点","slug":"iframe","date":"2016-04-15T13:00:59.000Z","updated":"2018-06-01T15:16:53.575Z","comments":true,"path":"2016/04/15/iframe/","link":"","permalink":"http://www.whbxyr.cn/2016/04/15/iframe/","excerpt":"","text":"iframe的优点 iframe能够将嵌入的网页原封不动地显示出来 用iframe来实现具有统一风格的网页（相同的头部、底部） 修改方便，多个网页引用iframe，修改一处实现全部修改 iframe的缺点 iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差 搜索引擎的检索程序无法解读这种页面，不利于SEO iframe会阻塞主页面的Onload事件 会影响页面的并行加载，解决方法是使用js动态给iframe的src加载页面内容，示例代码如下：1234&lt;iframe id=\"iframe\"&gt;&lt;/iframe&gt;&lt;script&gt;document.getElementById(\"iframe\").src = \"a2.html\";&lt;/script&gt;","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"html","slug":"html","permalink":"http://www.whbxyr.cn/tags/html/"}]},{"title":"排序算法总结","slug":"sortAlgorithm","date":"2016-04-02T05:19:03.000Z","updated":"2018-06-01T15:16:53.591Z","comments":true,"path":"2016/04/02/sortAlgorithm/","link":"","permalink":"http://www.whbxyr.cn/2016/04/02/sortAlgorithm/","excerpt":"","text":"各大排序算法综合总结 详解中包括了时间复杂度（最差/平均/最优），面试宝典 算法 最差 平均 最优 空间 稳定性 直接插入排序 O(n^2) O(n^2) O(n) O(1) 稳定 希尔排序 O(nlogn) O(nlogn) 视情况而定 O(1) 不稳定 基数排序 O(d(n+r)) O(d(n+r)) O(d(n+r)) O(n+r) 稳定 快速排序 O(n^2) O(nlogn) O(nlogn) O(nlogn) 不稳定 选择排序 O(n^2) O(n^2) O(n^2) O(1) 不稳定 冒泡排序 O(n^2) O(n^2) O(n) O(1) 稳定 桶排序 O(n) O(n) O(n) max 稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(1) 稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定 这些都是面试的时候比较经常问的排序算法，有错误可以发邮件给我！","categories":[{"name":"技术类-算法","slug":"技术类-算法","permalink":"http://www.whbxyr.cn/categories/技术类-算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.whbxyr.cn/tags/算法/"}]},{"title":"ajax 的兼容使用方法","slug":"ajax","date":"2015-04-18T05:45:07.000Z","updated":"2018-06-01T15:16:53.560Z","comments":true,"path":"2015/04/18/ajax/","link":"","permalink":"http://www.whbxyr.cn/2015/04/18/ajax/","excerpt":"","text":"简介&emsp;&emsp;Ajax技术的核心是XMLHttpRequest对象（简称XHR对象），这是由微软首先引入的一个特性。Ajax是对Asynchronous JavaScript + XML的简写，但Ajax通信与数据格式无关，这种技术是无须刷新页面即可从服务器取得数据，但不一定是XML数据。 &emsp;&emsp;IE5是第一款引入XHR对象的浏览器。在IE5中，XHR对象是通过MSXML库中的一个ActiveX对象实现的。因此，在IE中可能会遇到三种不同版本的XHR对象，即MSXML2.XMLHttp、MSXML2.XMLHttp.3.0、MSXML2.XMLHttp.6.0。因此，为了兼容浏览器IE 6-，必须写一个函数去根据IE中可用的MSXML库的情况创建最新版本的XHR对象。 &emsp;&emsp;而 IE 7+、Firefox、Opera、Chrome 和 Safari 都支持原生的XHR对象，在这些浏览器中创建XHR对象要像下面这样使用XMLHttpRequest构造函数。1var xhr = new XMLHttpRequest(); 兼容函数createXHR12345678910111213141516171819202122232425function createXHR() &#123; if (typeof XMLHttpRequest !== 'undefined') &#123; return new XMLHttpRequst(); &#125; else if (typeof ActiveXObject !== 'undefined') &#123; if (typeof arguments.callee.activeXString !== 'string')&#123; var versions = ['MSXML2.XMLHttp', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp.6.0']; var i, len; for (var i = 0, len = versions.length; i &lt; len; i++) &#123; try &#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex) &#123; // 跳过 &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXObject); &#125; else &#123; throw new Error('No XHR object available'); &#125;&#125; &emsp;&emsp;这个函数首先检测原生XHR对象是否存在，如果它存在则返回它的新实例，否则检测ActiveXObject对象。如果这两种对象都不存在，就抛出一个错误。然后，就可以使用下面的代码在所有的浏览器中创建XHR对象了。1var xhr = createXHR(); XHR的具体使用方法&emsp;&emsp;XHR对象的通用使用方法如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var xhr = createXHR();// 异步的ajax请求可以检测XHR对象的readyState属性，该属性表示请求/响应过程的当前活动阶段// 0：未初始化。刚创建XHR对象，尚未调用open()方法// 1：启动。已经调用open()方法，但尚未调用send()方法// 2：发送。已经调用send()方法，但尚未接收到响应// 3：接收。已经接收到部分响应数据// 4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; // 服务器响应的数据会自动填充XHR对象的属性，相关的属性如下： // responseText：作为响应主体被返回的文本 // responseXMl：如果响应的内容类型是“text/xml”或“application/xml”，这个属性中将保存包含着响应数据的 XML DOM 文档 // status：响应的 HTTP 状态 // statusText：HTTP 状态的说明 alert(xhr.responseText); // 调用getResponseHeader()或者getAllResponseHeaders()可以取得相应的响应头部信息 var myHeader = xhr.getResponseHeader('MyHeader'); var allHeaders = xhr.getAllResponseHeaders(); &#125; else &#123; alert('Request was unsuccessful: ' + xhr.status); &#125; &#125;&#125;;// 查询字符串中每个参数的键和值都必须使用encodeURIComponent()进行编码才追加到URL末尾function addURLParam(url, name, value) &#123; url += (url.indexOf('?') === -1 ? '?' : '&amp;'); url += encodeURIComponent(name) + '=' + encodeURIComponent(value); return url;&#125;var url = 'example.php';// 添加参数url = addURLParam(url, 'name', 'Ray');url = addURLParam(url, 'book', 'Green Story');// 第一个参数可为“get”、“post”等// 第三个参数为true表示ajax请求为异步的，否则为同步的xhr.open('get', url, true);// 若要调用setRequestHeader()方法，必须在open()之后，send()之前xhr.setRequestHeader('MyHeader', 'MyValue');xhr.send(null);// 在接收到响应之前还可以调用abort()方法取消异步请求// xhr.abort();// 以上使用的是get的提交方式，以下以一个post提交方式的ajax请求来模拟表单提交xhr.open('post', 'postexample.php', true);// 使用post提交方式必须声明这个头部，表示表单提交时的内容类型xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');var form = document.getElementById('user-info');// 序列化页面中的“表单数据”并发送xhr.send(serialize(form)); 总结 负责Ajax运作的核心对象是XMLHttpRequest（XHR）对象。 XHR对象由微软最早在IE5中引入，用于通过JavaScript从服务器取得XML数据。 在此之后，Firefox、Safari、Chrome 和 Opera都是实现了相同的特性，使XHR成为了Web的一个事实标准。 虽然实现之间存在差异，但XHR对象的基本使用方法在不同浏览器间还是相对规范的，因此可以放心地用在Web开发当中。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"},{"name":"ajax","slug":"ajax","permalink":"http://www.whbxyr.cn/tags/ajax/"}]},{"title":"详解 JSON 以及 JSON 在JS中的使用","slug":"json","date":"2015-03-16T08:03:50.000Z","updated":"2018-06-01T15:16:53.575Z","comments":true,"path":"2015/03/16/json/","link":"","permalink":"http://www.whbxyr.cn/2015/03/16/json/","excerpt":"","text":"简介&emsp;&emsp;JSON是一种数据结构而不是一种编程语言，它利用了JS中的一些模式来表示结构化数据，虽然与JS具有相同的语法形式，但是JSON并不从属于JS。另外，并不是只有JS才使用JSON，很对编程语言都有针对JSON的解析器和序列化器。 JSON的语法一. 取值类型&emsp;&emsp;简单值： 可以在JSON中表示字符串、数值、布尔值和null，但不支持特殊值undefined。&emsp;&emsp;对象： 复杂数据类型，表示一组无序的键值对，每个键值对中的值可以是简单值，也可以是复杂数据类型的值。&emsp;&emsp;数组： 复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值，该值也可以是简单值、对象或者数组。 二. 语法&emsp;&emsp;JSON没有变量的概念，末尾没有分号，属性必须加双引号，举例如下：12345678&#123; \"name\": \"Ray\", \"age\": 20, \"school\": &#123; \"name\": \"GDUT\", \"location\": \"CHINA\" &#125;&#125; &emsp;&emsp;JSON数组：12345678910111213141516171819202122232425262728293031// 示例一[20, \"hi\", true]// 示例二[ &#123; \"title\": \"Story One\", \"authors\": [ \"Ray\" ], \"edition\": 3, \"year\": 2017 &#125;, &#123; \"title\": \"Story Two\", \"authors\": [ \"Tom\" ], \"edition\": 2, \"year\": 2016 &#125;, &#123; \"title\": \"Story Three\", \"authors\": [ \"Amy\", \"Sara\", \"Jack\" ], \"edition\": 4, \"year\": 2014 &#125;] 解析与序列化&emsp;&emsp;ECMAScript 5对解析JSON的行为进行规范，定义了全局对象JSON，支持这个对象的浏览器有 IE 8+、Firefox 3.5+、Safari 4+、Chrome 和 Opera 10.5+。对于较早的、不能原生支持JSON解析的浏览器，可以使用一个shim：https://github.com/douglascrockford/JSON-js，这比使用eval()对JSON数据结构求值要安全，避免了一些恶意代码的执行。 一. 序列化&emsp;&emsp;JSON.stringify()用于将JS对象序列化为JSON字符串。在序列化JS对象时，所有函数及原型成员都会被有意忽略，不体现在结果中，此外，值为undefined的任何属性也会被跳过。举例如下：12345678910var book = &#123; title: \"Story One\", authors: [ \"Ray\" ], edition: 3, year: 2017&#125;;var jsonText = JSON.stringify(book);// jsonText中的字符串： &#123;\"title\":\"Story One\",\"authors\":[\"Ray\"],\"edition\":3,\"year\":2017&#125; &emsp;&emsp;JSON.stringify()还可以另外接收两个可选的参数，第一个参数是个过滤器，值为一个数组或者一个函数，举例如下：12345678910111213141516171819202122232425var book = &#123; \"title\": \"Story One\", \"authors\": [ \"Ray\" ], edition: 3, year: 2017&#125;;// 第二个参数为一个数组，表示只保留相应的属性var jsonText = JSON.stringify(book, [\"title\", \"edition\"]);// jsonText中的字符串： &#123;\"title\":\"Story One\",\"edition\":3&#125;// 第二个参数为一个函数，通过返回指定相应属性的值，返回undefined表示删除该属性。实际上，第一次调用这个函数过滤器，传入的是一个空字符串，而值就是book对象。var jsonText = JSON.stringify(book, function (key, value) &#123; switch (key) &#123; case \"authors\": return value.join(\",\"); case \"year\": return 5000; case \"edition\": return undefined; default: return value; &#125;;&#125;);// jsonText中的字符串： &#123;\"title\":\"Story One\",\"authors\":\"Ray\",\"year\":5000&#125; &emsp;&emsp;JSON.stringify()接收最后一个（第三个）参数来表示是否在JSON字符串中保留缩进。举例如下：1234567891011121314151617181920212223242526272829303132var book = &#123; \"title\": \"Story One\", \"authors\": [ \"Ray\" ], edition: 3, year: 2017&#125;;// 第三个参数为一个数值，表示每个级别缩进的空格数var jsonText = JSON.stringify(book, null, 4);/* jsonText中的字符串：&#123; \"title\": \"Story One\", \"authors\": [ \"Ray\" ], \"edition\": 3, \"year\": 2017&#125;*/// 第三个参数为一个字符串，使用这个字符串作为缩进字符var jsonText = JSON.stringify(book, null, \" - -\");/* jsonText中的字符串：&#123; - -\"title\": \"Story One\", - -\"authors\": [ - - - -\"Ray\" - -], - -\"edition\": 3, - -\"year\": 2017&#125;*/ &emsp;&emsp;给对象定义toJSON()方法，返回指定的JSON数据格式。可以为任何对象添加toJSON()方法。举例如下：12345678910111213var book = &#123; \"title\": \"Story One\", \"authors\": [ \"Ray\" ], edition: 3, year: 2017, toJSON: function () &#123; return this.title; &#125;&#125;;var jsonText = JSON.stringify(book);// jsonText中的字符串(包括了两个双引号)： \"Story One\" &emsp;&emsp;toJSON()可以作为函数过滤器的补充，因此理解序列化的内部顺序十分重要，假设把一个对象传入JSON.stringify()，序列化该对象的顺序如下：（1）如果存在toJSON()方法而且能通过它取得有效的值，则调用该方法。否则，返回对象自身。（2）如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第（1）步返回的值。（3）对第（2）步返回的每个值进行相应的序列化。（4）如果提供了第三个参数，执行相应的格式化。 二. 解析&emsp;&emsp;JSON.parse()用于将JSON字符串解析为原生的JS值。&emsp;&emsp;JSON.parse()还可以接收另外一个参数，该参数是一个函数，称作还原函数，该还原函数返回undefined，表示要从结果中删除相应的键，如果返回其他值，则将该值插入到结果中。举例如下：12345678910111213141516171819var book = &#123; \"title\": \"Story One\", \"authors\": [ \"Ray\" ], edition: 3, year: 2015, releaseDate: new Date(2015, 3, 1)&#125;;var jsonText = JSON.stringify(book);var bookCopy = JSON.parse(jsonText, function (key, value) &#123; if (key === \"releaseDate\") &#123; return new Date(value); &#125; else &#123; return value; &#125;&#125;);// 执行 bookCopy.releaseDate.getFullYear()，得到数值2015 总结&emsp;&emsp;JSON是一种轻量级的数据格式，可以简化表示复杂数据结构的工作量。JSON使用JS语法的子集表示对象、数组、字符串、数值、布尔值和null。即使XML也能表示同样复杂的数据结果，但是JSON没有XML那么繁琐，而且在JS中使用十分便利。我们可以使用ECMAScript 5定义的原生JSON对象的两个方法stringify()以及parse()来将JS对象序列化为JSON字符串或者将JSON字符串数据解析为JS对象。","categories":[{"name":"技术类-前端","slug":"技术类-前端","permalink":"http://www.whbxyr.cn/categories/技术类-前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.whbxyr.cn/tags/JavaScript/"}]}]}